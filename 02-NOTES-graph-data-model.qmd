---
title: "Graph Data Model" 
---

## Graph Data Model for Timetabling (1000 words)

### 2.1 Comparison of Relational and Graph Models
* Visual representation of both models - mermaid, or simmilar

### 2.2 Advantages of the Graph Approach

### 2.3 Data Augmentation Opportunities
* Room properties example (lat, long)
* Potential for additional data integration (curriculum, student outcomes, etc.)


2 Graph Data Model
Given the highly relational nature of timetables, where courses, instructors, rooms, and time slots are interconnected in intricate ways, it is hypothesized that a graph-based approach could offer a more natural and insightful way to represent and analyze timetable data. Graph databases, designed to handle complex relationships and interconnected data, have the potential to unlock new avenues for understanding and optimizing university timetables.

2.1 Graph vs. Relational Data Structures (General)
In the realm of data management, two prominent paradigms exist: the relational model and the graph model. The relational model, exemplified by relational databases like SQL Server, MySQL, and PostgreSQL, organizes data into tables with rows and columns. Each row represents an entity, and columns store the attributes of that entity. Relationships between entities are established through foreign keys, creating a structured and rigid schema.

In contrast, the graph model, employed by graph databases like Neo4j, Amazon Neptune, and Microsoft Azure Cosmos DB, represents data as nodes and edges. Nodes are the fundamental entities, and edges define the relationships between them. Both nodes and edges can have properties, allowing for flexible and dynamic schemas.

The choice between relational and graph databases depends on the nature of the data and the types of queries that need to be executed. Relational databases excel at structured data with well-defined relationships, making them suitable for transactional systems and reporting. However, they can become cumbersome when dealing with complex, interconnected data, as queries often involve multiple joins across tables, leading to performance bottlenecks.

Graph databases, on the other hand, are designed to handle complex relationships and interconnected data naturally. They shine in scenarios where the focus is on exploring relationships, traversing networks, and uncovering patterns in interconnected data. Graph databases offer superior performance for queries that involve traversing multiple relationships, as the relationships are explicitly represented as edges in the graph.

2.2 Pros and Cons of Graph Databases
Graph databases offer several advantages over relational databases, particularly when dealing with highly connected data:

Flexibility: Graph databases allow for flexible and dynamic schemas, making it easy to add new types of nodes and edges as the data evolves. This flexibility is crucial in domains like university timetabling, where the relationships between entities can be complex and subject to change.
Scalability: Graph databases are designed to scale horizontally, distributing data across multiple machines to handle large datasets and high query volumes. This scalability is essential for university timetabling, as the number of courses, students, and instructors can be substantial.
Performance: Graph databases excel at traversing relationships, making them ideal for queries that involve exploring connections between entities. In the context of university timetabling, this translates to faster and more efficient queries for tasks like finding all courses taught by a particular instructor or identifying scheduling conflicts.
Expressiveness: Graph query languages, such as Cypher, are designed to express complex relationship-based queries concisely. This expressiveness simplifies the formulation of queries that would be cumbersome in SQL, the query language for relational databases.
However, graph databases also have some limitations:

Maturity: Graph database technology is relatively young compared to relational databases, and the ecosystem of tools and libraries is still evolving.
Learning Curve: Graph query languages, while expressive, require a learning curve for those familiar with SQL.
Limited Support for Aggregation: Graph databases are not optimized for aggregation queries, such as calculating averages or sums, which are common in relational databases.
2.3 Comparison of Timetable Data in Relational and Graph Structures
In a relational database, timetable data is typically organized into tables, with each table representing an entity like courses, rooms, instructors, and time slots. Relationships between entities are established through foreign keys, creating a structured schema. For example, a "course" table might have columns for course code, name, and credits, while an "instructor" table might have columns for instructor ID, name, and department. A "schedule" table would then link courses, instructors, rooms, and time slots using foreign keys.

In contrast, a graph database represents timetable data as nodes and edges. Nodes represent entities like courses, rooms, instructors, and time slots, while edges represent relationships between them. For instance, an edge labeled "scheduled_in" could connect a course node to a room node, indicating that the course is scheduled in that room. Similarly, an edge labeled "taught_by" could connect a course node to an instructor node, signifying that the course is taught by that instructor.