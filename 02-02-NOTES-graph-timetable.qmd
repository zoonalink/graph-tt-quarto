---
title: Graph Data Model for Timebling
---

::: callout-warning
## TODO

DELETE
:::

2.3 Graph Data Model for Timetabling

Detailed description of proposed graph model
Node types (e.g., courses, instructors, rooms, time slots)
Edge types (e.g., "scheduled_in", "taught_by")
Properties for nodes and edges


# approach

iterative: design, build, test, review, revise and back to design
Used: neo4j desktop and cloud instance
started small (data wise -> me and complexity (minimal nodes, minimal properties)
things went wrong - many examples of wrong nodes, multiple relationships or more frustratingly - failure and error codes


# nodes

The key nodes (nouns) in a timetable are: 

* Student (Person)
* Staff (Person)
* Activity (Event)
* Room (Location) 

The key nodes (nouns) are:

| Node     | Property    | Description           | Data Type |
|----------|-------------|-----------------------|-----------|
| Student  | firstName   | Legal first name      | string    |
|          | lastName    | Legal last name       | string    |
|          | studentID   | University identifier | integer   |
|          | splusID     | Timetable URN         | string    |
| Lecturer | firstName   | First name            | string    |
|          | lastName    | Last name             | string    |
|          | staffID     | University identifier | integer   |
|          | splusID     | Timetable URN         | string    |
| Room     | name        | Room name             | string    |
|          | splusID     | Timetable URN         | integer   |
| Activity | name        | Activity name         | string    |
|          | description | Activity description  | string    |
|          | startTime   | Scheduled start time  | datetime  |
|          | endTime     | Scheduled end time    | datetime  |
|          | date        | Date of activity      | date      |

* sample cypher of loading self (v1-core-load-student-node.png)
* results v1-core-load-all-nodes.png


* example of a student node (me) ![student detail](../images/v1.1-core-student-phl.png)
* all nodes loaded for MSc Data Science 2022-23 students: 
  * ![all-nodes-for-posi](../images/v1.1-load-all-nodes.png)
  * no relationships
# relationships

The nodes are related as follows: 

* `Student` *allocated to* `Activity`
    * alternatives include *attends*
* `Staff` *teaches on* `Activity`
    * alternatives include *lectures*, *leads*, etc.
* `Activity` *takes place in* `Room`
    * alternatives include *scheduled in*

It is clear that `Activity` is the central node in the basic model.

![core nodes with relationships](attachment:v1-core-nodes-rels.png)

* loaded into neo4j ![v1.1 full model](../images/v1.1-core-full-model.png)
  * two clusters?  waht are they
  * some orphans?  who/waht are they?

* basic query examples - probably not worth 
  * staff with most activities, hours
  * average hours per student, per programme
  * most popular activities
  * most popular tutors (attendance)
  * days with most activities
  * times with most activities / scheduled hours/start times
  * histogram of activities by day
  * most popular combinations (modules, pairs of modules, triplets)
    * most attended 
  * most attendance percentage
  * relationship between attendance and time/day of activity
  * anomalies, combinations

# properties

* dependent on use cases - which questions are to be answered
* some may be better as nodes, others as properties on node or properties on relationship
* no right or wrong - highly experimental, needs to be tested, optimised
* flexbility of graph to accommodate

* each node person/student, person/staff, activity, room needs some properties
  * name, id, description
  * activity needs date, times, (although modelling time has many varieties)

image of final proof of concept simple model: v1-core-nodes-rels-prop.png


# expansions

more nodes from timetable db could include:

* organisational unit (department, college, school)
* curriculum data (module, programme) - activity is part of module, programme made of modules (compulsory, optional)
* students who are pal leaders (as a mentoring relationship)
* activity type (property or node) - lecture, seminar, workshop, lab
* delivery type (property or node) - online, on-campus, recorded, optional, drop-in
* technician staff facilitating workshops
* equipment requirements in rooms



more student properties could include:
* reasonable adjustments
* international student
* first year student
* pal leader

example of expanded model: ![Title](../images/v2.0-expanded-tt.png)

this would allow for quickly getting insights such as: 

* Identify students with anomalous timetables - e.g. timetables that have gaps of more than 2 hours between activities, or that violate a policy of no more than X hours per day. 
* Find the **busiest locations** on campus - analyse room nodes to identify those with the most connected activity nodes on a given day. Useful for improving room bookings.
* Identify **outlier teaching loads** - find staff with significantly more or fewer allocated teaching hours compared to their peers. Analyse each staff node's connected activity nodes and sum the durations
* Analyse **room utilisation** - calculate the percentage of available hours that rooms are booked based on their connected activities. Help optimise room usage.
* Identify **module co-dependencies** - find modules that are often taken together by analysing frequent appearing :CONTRIBUTES_TOWARDS relationships between modules taken by the same students.
* **Cluster students** based on their curriculum/programs using community detection algorithms on the connections between student nodes, program nodes and module nodes. Identify common trajectories.
* **Predict student results** - build a model based on relationships between student attributes, their enrollment relationships to modules, module difficulties and prerequisites, and historical grade data
* Make **course recommendations** - suggest new modules to students based on their existing modules and other similar students' module relationships.

then the possible:

* adding more location data - buildings, latitude, longitude
* student details - home postcode (travel distance), 
* student outcomes - module marks, award outcomes, graduate outcomes
* admissions data - (free lunch scheme, social economic data, a-level results, inclusivity insights)
* curriculum data - from master curriculum data
* engagement data - attendance, engagement
* space use data - wifi locators, how busy areas are, correlations
* 


## time

modelling time in graph was challenging.  my simple model above does take time into account other than to have startTime, endTime, date.  In reality, an activity can take have the same start time, end time but be scheduled over several weeks - sometimes consecutive, sometimes non-consecutive weeks.  How should this be represented?  week patterns?  date ranges?  or separate activities?  what happens when an activity is scheduled over several days but the same time over several weeks for example, Mondays and Wednesdays between 09:00-11:00 for ten weeks?

this is where normalisation (footnote) and different designs come into play.  In a relational database, it is fairly easy to normalise the data into activities where start and end time and day(s) of week, staff, locations, students are the same for the week pattern.  Any deviation will require a new 'activity' to accommodate the difference.  Therefore there is an inevitable repetition of data.

In graph these scenarios can be handled in different ways.  My initial model simply ported data as string data to an activity - that is, I literally created an activity as it existed in database and added start time, end time, weeks, etc. as properties of the activity.  

This worked to an extent but it was not optimised for calculating on time.  

I anticipated being able to answer questions and identify patterns like:

* students on programmes who do not have a lunch break (12:00-14:00)
* students who have X hours consecutive teaching without a break
* students who have X hours between teaching activities on any given date (e.g. early activity (09:00-10:00) and late finish (18:00-19:00))

Being able to answer these types of queries easily will help pinpoint where there may be timetable quality concerns.

I considered and explored differnet options including:

1. activities with 52 week patterns (0000011101 etc.), start and end times
2. activities which are unique combinations of date, start, end, name
3. activities with date ranges, start and end times
4. activities linked to start time, end time and date nodes

At this point, I did remember the project's scope and reminded myself that it is a proof of concept.  I settled for option 2 - where each activity is a unique combination of start, end, date and name.  This required transforming from sql - there is some loss of redundancy but calculations on times are more manageable (although not uncomplicated).  Also being restricted by Neo4j's free aura instance, there is a limit to nodes (200K) and relationships (400K) which I would hit quickly.

My suspicion is that creating separate nodes for start and end times and dates dynamically from the activity data would be the better model - but this will need to be future work with direct comparisons aganst specific use cases and insights. 


## appendix - 

### example load

#### Attempt 2 - load separately

```cypher
// remove all relationships
MATCH ()-[r]-() 
DELETE r
```


**activity-room**

```cypher
// Activity-Room
LOAD CSV WITH HEADERS FROM "file:///phl-rel-room-activity.csv" AS row3
MATCH (r:Room {roomSplusID: row3.roomSplusID}) 
MATCH (a:Activity {activitySplusID: row3.activitySplusID})
CREATE (a)-[:TAKES_PLACE_IN]->(r)
```
**activity-staff**

```cypher
// Staff-activity 
LOAD CSV WITH HEADERS FROM "file:///phl-rel-staff-activity.csv" AS row2
MATCH (s:Staff {staffSplusID: row2.staffSplusID}) 
MATCH (a:Activity {activitySplusID: row2.activitySplusID})
CREATE (s)-[:TEACHES_ON]->(a)
```

**activity-student**

```cypher
// Student-Activity
LOAD CSV WITH HEADERS FROM "file:///phl-rel-student-activity.csv" AS row
MATCH (s:Student {studentSplusID: row.studentSplusID}) 
MATCH (a:Activity {activitySplusID: row.activitySplusID})
CREATE (s)-[:IS_ALLOCATED_TO]->(a)
```

# results

v1-core-poc.png

