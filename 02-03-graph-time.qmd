---
title: Graphing Time
---

::: callout-warning
## TODO

-   quote on normalisation (footnote)
-   add arrows for each model
:::

The biggest challenge I encountered when modelling timetables into graph data structures involved temporal elements - that is, start and end times, dates, weeks, reccurences, durations, etc. Whether a data element is a node or a property of a node, or perhaps both is relatively trivial to model and test, and depends heavily on use cases. Time, on the other hand, is complicated, especially when you want to write aggregation queries on time elements.

While the conceptual flexibility of graphs is appealing, finding the optimal balance between efficient representation, query performance, and data redundancy requires careful consideration. This section details some challenges encountered and the approach taken for the proof-of-concept.

## The Problem of Normalised Time

Traditional relational databases often store timetable information in a highly normalised format, condensing recurring events into single rows with date ranges, week patterns, or lists of occurrences. While efficient for storage and basic display, this approach severely hinders analysis, especially when aiming to:

-   **Identify Time-Based Patterns**: Determining if students lack lunch breaks or experience excessive gaps between classes becomes difficult when time is fragmented across multiple fields.
-   **Perform Aggregations**: Calculating total teaching hours for a lecturer across specific weeks or days requires complex queries and data transformations.
-   **Model Temporal Relationships**: Representing relationships between activities based on their temporal proximity, such as students attending consecutive classes, becomes convoluted.

## Exploring Potential Solutions



To address these challenges, several time modelling approaches were explored, each with its own trade-offs. Let's explore using a fictional example - `Introduction to Graph Databases`:

| Name | Day       | StartTime | EndTime | Weeks (11 weeks total) |
|------|-----------|-----------|---------|------------------|
| ITGD | Wednesday | 09:00     | 11:00   | 1-3, 5-7, 9-13   |
| ITGD | Wednesday  | 10:00     | 13:00   | 4, 7-8, 15         |
| ITGD | Monday    | 13:00     | 16:00   | 4, 7-8, 15         |

: Example Source Data (Relational)

### Option 0: Proof-of-concept activity

The basic model created nodes for each activity as they exist in the relational database.  This simple approach is perfectly acceptable, but makes any time based calculations difficult because each activity node can represent a different number of activities because of the week ranges (number of occurrences).

![Basic example](./images/time-option0.png)

If all students attend on Wednesday 09:00-11:00 (lecture) and only one of Monday or Thursday (seminar), some students will have a clash in week 7 between 10:00-11:00 .  Unpicking this from the normalised activities is very challenging and not immediately obvious at a glance.  

### Option 1: Unique Activity Nodes

Option 1 creates nodes for each unique combination of `name`, `startTime`, `endTime` and `date` - this means de-normalising the relational data and deliberately introducing duplication.

![Unique Activity Nodes Graph Example](./images/time-option1.png)

**Graph Structure**: 

- 11 separate `Activity` nodes one for each occurrence (date) 
- Each node has `date`, `startTime`, `endTime` properties

```         
(Activity {Name: "ITGD", Date: "2024-01-03", StartTime: "09:00", EndTime: "11:00"}) 
(Activity {Name: "ITGD", Date: "2024-01-10", StartTime: "09:00", EndTime: "11:00"}) 
... 
(Activity {Name: "ITGD", Date: "2024-03-20", StartTime: "09:00", EndTime: "11:00"})
```


**Pros**:

-   **Conceptual Simplicity**: Easy to understand and implement.
-   **Direct Time Representation**: Time is directly associated with each activity instance.

**Cons**:

-   **Node Proliferation**: Leads to a high volume of nodes, potentially impacting performance with large datasets.
-   **Complex Time-Based Queries**: Answering questions about time patterns or conflicts requires traversing numerous nodes and relationships.

### Option 2: Date and Time Nodes

Option 2 creates a single activity node but also additional `date` and `time` nodes, as required.  

![Time and Date Nodes](./images/time-option2.png)

**Graph Structure**: 

- 11 Date nodes
- 2 Time nodes (09:00 and 11:00) - shared by ALL activities on those times!

- **Additional Relationships**
- 
  - `Activity` -[:SCHEDULED_ON]-> `Date` (11 relationships)
  - `Date` -[:STARTS_AT]-> `Time` (11 relationships to 09:00)
  - `Date` -[:ENDS_AT]-> `Time` (11 relationships to 11:00)



```
(Activity {Name: "ITGD"}) -[:SCHEDULED_ON]-> (Date {date: "2024-01-03"}) -[:STARTS_AT]-> (Time {time: "09:00"})
                                             (Date {date: "2024-01-03"}) -[:ENDS_AT]->   (Time {time: "11:00"})
(Activity {Name: "ITGD"}) -[:SCHEDULED_ON]-> (Date {date: "2024-01-10"}) -[:STARTS_AT]-> (Time {time: "09:00"}) // Same time node!
                                             (Date {date: "2024-01-10"}) -[:ENDS_AT]->   (Time {time: "11:00"}) 
...
```

**Key point**:  Relationships encode which activity happens when.

**Pros**:

-   **Increased Flexibility**: Facilitates queries across time ranges and aggregations across time slots.
-   **Reduced Redundancy**: Avoids replicating time information for activities occurring on the same date and time.
-   **Lower Node Count**:  Potentially fewer nodes overall compared to Option 1 as `date` and `time` nodes are shared with all activities in the database.

**Cons**:

- **Increased Model Complexity**: Requires managing relationships between Activity, Date, and Time nodes. 
- **Potential Performance Overhead**: Querying might involve traversing multiple relationships, impacting efficiency.

### Option 3: Date and Time Block Nodes

Option 3 creates a single activity but instead of individual start and end time nodes, we use predetermined `timeBlocks` encompassing both.  For example, if using 30-minute blocks, we would have a node for "09:00-09:30" and another for "09:30-10:00", etc.

![TimeBlock and Date Nodes](./images/time-option3.png)

**Graph Structure**: 

- 11 Date nodes
- 4 Timeblock nodes (09:00-09:30, etc.) - shared by ALL activities on those times!

- **Additional Relationships**
- 
  - `Activity` -[:SCHEDULED_ON]-> `Date` (11 relationships)
  - `Date` -[:TAKES_PLACE_DURING]-> `timeBlock 09:00-09:30` (11 relationships)
  - `Date` -[:TAKES_PLACE_DURING]-> `timeBlock 09:30-10:00` (11 relationships)

```
(Activity {Name: "ITGD"}) -[:SCHEDULED_ON]-> (Date {date: "2024-01-03"}) -[:OCCUPIES]-> (TimeBlock {start: "09:00", end: "09:30"})
                                                                          -[:OCCUPIES]-> (TimeBlock {start: "09:30", end: "10:00"}) 
...
```

**Pros**:

-   **Granular Time Representation**: Enables analysis at specific time intervals
-   **Easier Time Calculations**: Duration is encoded and allows for easy calculations.
-   **Reduced Node Count Compared to Option 2**: Offers a balance between granularity and node proliferation.

**Cons**:

-   **Potential for Data Sparsity**: Some time blocks might be sparsely populated, leading to storage inefficiencies.
-   **Potential for High Node Codes**: Lots of `TimeBlocks` if using small intervals

### Option: Variations

**StartTime and Duration**: This option simplifies the model by representing time using only `StartTime` and `DurationInMinutes` properties on the `Activity` node, omitting explicit `EndTime` nodes.  This approach is suitable for duration based queries but it is limiting in that it is more difficult to query events occurring at specific times, overlapping time ranges or on end-times.

**Dynamic TimeBlocks**: This variation does not pre-create timeblocks based on a set interval (e.g. 30 minutes).  They are created dynamically as required by the data and what already exists.  For example, activities at 09:00-11:00, 10:30-11:30 and 11:00-12:00 would require these TimeBlocks:

```
(Timeblock {name: "09:00-11:00", start: 09:00, end: 11:00, duration:120})
(Timeblock {name: "10:30-11:30", start: 10:30, end: 11:30, duration:60})
(Timeblock {name: "11:00-12:00", start: 11:00, end: 12:00, duration:60})
```

### Summary


| Option | Pros       | Cons | 
|------|-----------|-----------|
| Unique Activities | Simple, direct | High node count, complex time pattern queries |
| Date & Time | Lower node count, good for time-based queries | More complex relationships |
| Date & TimeBlock | Granular, easier duration calculations | Potentially high node count, sparsity if blocks are fine-grained |


: Option summary 


Given the proof-of-concept scope of this project, I chose Option 1. While this approach can lead to node proliferation, it offers the most straightforward implementation for exploring fundamental time-based queries and insights.  It also acts as an easy jumping off point for exploring any of the other options.