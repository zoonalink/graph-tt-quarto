{
  "hash": "22b7e935221e6ab7976fe0f9eb2b4c96",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Student Clashes - Deeper Dive\"\nlightbox:\n  match: auto\n  effect: fade\n  desc-position: bottom\n  loop: false\n---\n\n\n\n<br>\n\nThis page explore different graph data structures and queries for the purposes of identifying student clashes.  It illustrates the inherent flexiblity of graph databases and that thorough modelling and profiling of the data can lead to more efficient and effective queries. \n\nUse-case is king when it comes to optimised databases and performant queries.\n\n## Scenario\n\nEach model below will use the same basic scenario:\n\n* Two students - Alice and Bob\n* Three activities:\n  * `ITGD` - Introduction to Graph Databases\n  * `Neo4j` - Neo4j for Beginners\n  * `TigerDB` - TigerGraph for Data Scientists\n  * Each activity has a start and end time\n  * Each activity is scheduled for several weeks\n* There are deliberate clashes between the activities to illustrate the concept of a student clash\n\n## Model 1 - Activity Occurrence\n\nEach 'occurrence' of an activity is a separate node.  This model is simple and easy to understand, but proliferates nodes which lead to inefficient and complex queries.\n\n### Create data\n\n\n\n\n```{cypher .scroll-cypher}\n// Create unique activity nodes (TestActivityModel1)\nCREATE (:TestActivityModel1 { actName: \"ITGD\", date: date(\"2024-08-06\"), startTime: localtime(\"09:00:00\"), endTime: localtime(\"11:00:00\") })\nCREATE (:TestActivityModel1 { actName: \"ITGD\", date: date(\"2024-08-13\"), startTime: localtime(\"09:00:00\"), endTime: localtime(\"11:00:00\") })\nCREATE (:TestActivityModel1 { actName: \"ITGD\", date: date(\"2024-08-20\"), startTime: localtime(\"09:00:00\"), endTime: localtime(\"11:00:00\") })\nCREATE (:TestActivityModel1 { actName: \"ITGD\", date: date(\"2024-08-27\"), startTime: localtime(\"09:00:00\"), endTime: localtime(\"11:00:00\") })\nCREATE (:TestActivityModel1 { actName: \"ITGD\", date: date(\"2024-09-03\"), startTime: localtime(\"09:00:00\"), endTime: localtime(\"11:00:00\") })\nCREATE (:TestActivityModel1 { actName: \"Neo4j\", date: date(\"2024-07-30\"), startTime: localtime(\"10:00:00\"), endTime: localtime(\"11:00:00\") })\nCREATE (:TestActivityModel1 { actName: \"Neo4j\", date: date(\"2024-08-13\"), startTime: localtime(\"10:00:00\"), endTime: localtime(\"11:00:00\") })\nCREATE (:TestActivityModel1 { actName: \"Neo4j\", date: date(\"2024-08-27\"), startTime: localtime(\"10:00:00\"), endTime: localtime(\"11:00:00\") })\nCREATE (:TestActivityModel1 { actName: \"TigerDb\", date: date(\"2024-08-06\"), startTime: localtime(\"11:00:00\"), endTime: localtime(\"12:00:00\") })\nCREATE (:TestActivityModel1 { actName: \"TigerDb\", date: date(\"2024-08-13\"), startTime: localtime(\"11:00:00\"), endTime: localtime(\"12:00:00\") });\n\n// Create unique student nodes (TestStudentModel1)\nCREATE (:TestStudentModel1 { stuFirstName_anon: \"Alice\", stuID_anon: \"test-student-1\" })\nCREATE (:TestStudentModel1 { stuFirstName_anon: \"Bob\", stuID_anon: \"test-student-2\" });\n\n// Create ATTENDS relationships (one student attends all TigerDb and Neo4j)\nMATCH (s:TestStudentModel1 { stuID_anon: \"test-student-1\" })\nMATCH (a:TestActivityModel1) WHERE a.actName IN [\"TigerDb\", \"Neo4j\"]\nCREATE (s)-[:ATTENDS]->(a);\n\nMATCH (s:TestStudentModel1 { stuID_anon: \"test-student-2\" })\nMATCH (a:TestActivityModel1) WHERE a.actName IN [\"ITGD\", \"Neo4j\"]\nMERGE (s)-[:ATTENDS]->(a) ;\n```\n\n\n\n![Model 1](./images/cypher-clash1-model.png)\n\nTo identify the clashes, this query can be run: \n\n\n\n\n```{cypher .scroll-cypher}\n\nMATCH (s:TestStudentModel1)-[:ATTENDS]->(a1:TestActivityModel1)\nWITH s, a1\nMATCH (s)-[:ATTENDS]->(a2:TestActivityModel1) \nWHERE a1 <> a2 \n  AND a1.date = a2.date \n  AND (a1.startTime < a2.endTime AND a1.endTime > a2.startTime)  //  overlap condition\n  AND NOT (a1.startTime = a2.endTime OR a1.endTime = a2.startTime) // xxclude \"touching\" cases\n  AND a1.actName < a2.actName  // ensures only one direction of the pair is returned\nRETURN s.stuFirstName_anon AS Student, \n       a1.date AS ClashDate, \n       a1.actName AS Activity1, \n       a1.startTime + \"-\" + a1.endTime AS Timeslot1, \n       a2.actName AS Activity2, \n       a2.startTime + \"-\" + a2.endTime AS Timeslot2\nORDER BY Student, ClashDate;\n```\n\n\n\n\nWhich correctly identifies Bob's clash: \n\n![Model 1 results](./images/cypher-clash1-result.png)\n\nOne way of measuring and comparing query performance is to look at the `PROFILE` and `dbhits.`  In this instance there are 278 database accesses.\n\n![Model 1 profile](./images/cypher-clash1-db-hits.png)\n\n## Model 2 - Date and Time Nodes\n\nModel 2 uses a single node for each activity but has date and time nodes.  This model is more complex in that there are more node labels, but can be more efficient for certain queries.\n\n### Create data\n\n\n\n\n\n\n```{cypher .cypher-scroll}\n// Create unique time nodes\nCREATE (:TestStartTimeNode { time: localtime(\"09:00:00\") })\nCREATE (:TestStartTimeNode { time: localtime(\"10:00:00\") })\nCREATE (:TestStartTimeNode { time: localtime(\"11:00:00\") })\nCREATE (:TestEndTimeNode { time: localtime(\"11:00:00\") })\nCREATE (:TestEndTimeNode { time: localtime(\"12:00:00\") })\n\n// Create unique date nodes\nCREATE (:TestDateNode { date: date(\"2024-07-30\") })\nCREATE (:TestDateNode { date: date(\"2024-08-06\") })\nCREATE (:TestDateNode { date: date(\"2024-08-13\") })\nCREATE (:TestDateNode { date: date(\"2024-08-20\") })\nCREATE (:TestDateNode { date: date(\"2024-08-27\") })\nCREATE (:TestDateNode { date: date(\"2024-09-03\") })\n\n// Create activity nodes\nCREATE (:TestActivityModel2 { actName: \"ITGD\" })\nCREATE (:TestActivityModel2 { actName: \"Neo4j\" })\nCREATE (:TestActivityModel2 { actName: \"TigerDb\" });\n\n// Connect ITGD to dates and times (using MERGE)\nMATCH (a:TestActivityModel2 { actName: \"ITGD\" })\nMATCH (d:TestDateNode) WHERE d.date IN [date(\"2024-08-06\"), date(\"2024-08-13\"), date(\"2024-08-20\"), date(\"2024-08-27\"), date(\"2024-09-03\")]\nMERGE (a)-[:SCHEDULED_ON]->(d)\nWITH a\nMATCH (st:TestStartTimeNode { time: localtime(\"09:00:00\") })\nMATCH (et:TestEndTimeNode { time: localtime(\"11:00:00\") })\nMERGE (a)-[:STARTS_AT]->(st)\nMERGE (st)-[:ENDS_AT]->(et);\n\n// Connect Neo4j to dates and times (adjust dates/times and use MERGE)\nMATCH (a:TestActivityModel2 { actName: \"Neo4j\" })\nMATCH (d:TestDateNode) WHERE d.date IN [date(\"2024-07-30\"), date(\"2024-08-13\"), date(\"2024-08-27\")]\nMERGE (a)-[:SCHEDULED_ON]->(d)\nWITH a\nMATCH (st:TestStartTimeNode { time: localtime(\"10:00:00\") })\nMATCH (et:TestEndTimeNode { time: localtime(\"11:00:00\") })\nMERGE (a)-[:STARTS_AT]->(st)\nMERGE (st)-[:ENDS_AT]->(et);\n\n// Connect TigerDb to dates and times (adjust dates/times and use MERGE)\nMATCH (a:TestActivityModel2 { actName: \"TigerDb\" })\nMATCH (d:TestDateNode) WHERE d.date IN [date(\"2024-08-06\"), date(\"2024-08-13\")]\nMERGE (a)-[:SCHEDULED_ON]->(d)\nWITH a\nMATCH (st:TestStartTimeNode { time: localtime(\"11:00:00\") })\nMATCH (et:TestEndTimeNode { time: localtime(\"12:00:00\") })\nMERGE (a)-[:STARTS_AT]->(st)\nMERGE (st)-[:ENDS_AT]->(et);\n\n// Create Students and ATTENDS relationships (same as Model 1)\nCREATE (:TestStudentModel2 { stuFirstName_anon: \"Alice\", stuID_anon: \"test-student-1\" })\nCREATE (:TestStudentModel2 { stuFirstName_anon: \"Bob\", stuID_anon: \"test-student-2\" });\n\nMATCH (s:TestStudentModel2 { stuID_anon: \"test-student-1\" })\nMATCH (a:TestActivityModel2) WHERE a.actName IN [\"TigerDb\", \"Neo4j\"]\nCREATE (s)-[:ATTENDS]->(a);\n\nMATCH (s:TestStudentModel2 { stuID_anon: \"test-student-2\" })\nMATCH (a:TestActivityModel2) WHERE a.actName IN [\"ITGD\", \"Neo4j\"]\nMERGE (s)-[:ATTENDS]->(a) ;\n```\n\n\n\n\n![Model 2](./images/cypher-clash2-model.png)\n\nTo identify student clashes, this query can be run.\n\n\n\n\n```{cypher .cypher-scroll}\nMATCH (s:TestStudentModel2)-[:ATTENDS]->(a1:TestActivityModel2)-[:SCHEDULED_ON]->(d:TestDateNode)\nWITH s, a1, d\nMATCH (s)-[:ATTENDS]->(a2:TestActivityModel2)-[:SCHEDULED_ON]->(d) // Same date\nMATCH (a1)-[:STARTS_AT]->(st1:TestStartTimeNode)-[:ENDS_AT]->(et1:TestEndTimeNode) \nMATCH (a2)-[:STARTS_AT]->(st2:TestStartTimeNode)-[:ENDS_AT]->(et2:TestEndTimeNode) \nWHERE a1 <> a2 \n  AND (st1.time < et2.time AND et1.time > st2.time)  //  overlap condition\n  AND NOT (st1.time = et2.time OR et1.time = st2.time) // xxclude \"touching\" cases\n  AND a1.actName < a2.actName  // ensures only one direction of the pair is returned\nRETURN  s.stuFirstName_anon AS Student, \n        d.date AS ClashDate, \n        a1.actName AS Activity1, \n        st1.time + \"-\" + et1.time AS Timeslot1,\n        a2.actName AS Activity2,\n        st2.time + \"-\" + et2.time AS Timeslot2\nORDER BY Student, ClashDate;\n```\n\n\n\n\nThe results are the same as Model 1, but the profile is different, with fewer `database accesses` (143):\n\n![Model 2 profile](./images/cypher-clash2-db-hits.png)\n\n\n## Model 3 - Date Nodes \n\nModel 3 uses a single node for each activity as well as date nodes - start and end times are properties of the activity.\n\n\n\n\n```{cypher .cypher-scroll}\n// Create unique date nodes\nCREATE (:TestDateNodeModel3 { date: date(\"2024-07-30\") })\nCREATE (:TestDateNodeModel3 { date: date(\"2024-08-06\") })\nCREATE (:TestDateNodeModel3 { date: date(\"2024-08-13\") })\nCREATE (:TestDateNodeModel3 { date: date(\"2024-08-20\") })\nCREATE (:TestDateNodeModel3 { date: date(\"2024-08-27\") })\nCREATE (:TestDateNodeModel3 { date: date(\"2024-09-03\") })\n\n// Create activity nodes with start/end times as properties\nCREATE (:TestActivityModel3 { actName: \"ITGD\", startTime: localtime(\"09:00:00\"), endTime: localtime(\"11:00:00\") })\nCREATE (:TestActivityModel3 { actName: \"Neo4j\", startTime: localtime(\"10:00:00\"), endTime: localtime(\"11:00:00\") })\nCREATE (:TestActivityModel3 { actName: \"TigerDb\", startTime: localtime(\"11:00:00\"), endTime: localtime(\"12:00:00\") });\n\n// Connect Activities to Dates (using MERGE)\nMATCH (a:TestActivityModel3 { actName: \"ITGD\" })\nMATCH (d:TestDateNodeModel3) WHERE d.date IN [date(\"2024-08-06\"), date(\"2024-08-13\"), date(\"2024-08-20\"), date(\"2024-08-27\"), date(\"2024-09-03\")]\nMERGE (a)-[:SCHEDULED_ON]->(d);\n\nMATCH (a:TestActivityModel3 { actName: \"Neo4j\" })\nMATCH (d:TestDateNodeModel3) WHERE d.date IN [date(\"2024-07-30\"), date(\"2024-08-13\"), date(\"2024-08-27\")]\nMERGE (a)-[:SCHEDULED_ON]->(d);\n\nMATCH (a:TestActivityModel3 { actName: \"TigerDb\" })\nMATCH (d:TestDateNodeModel3) WHERE d.date IN [date(\"2024-08-06\"), date(\"2024-08-13\")]\nMERGE (a)-[:SCHEDULED_ON]->(d);\n\n// Create Students and ATTENDS relationships\nCREATE (:TestStudentModel3 { stuFirstName_anon: \"Alice\", stuID_anon: \"test-student-1\" })\nCREATE (:TestStudentModel3 { stuFirstName_anon: \"Bob\", stuID_anon: \"test-student-2\" });\n\nMATCH (s:TestStudentModel3 { stuID_anon: \"test-student-1\" })\nMATCH (a:TestActivityModel3) WHERE a.actName IN [\"TigerDb\", \"Neo4j\"]\nCREATE (s)-[:ATTENDS]->(a) ;\n\nMATCH (s:TestStudentModel3 { stuID_anon: \"test-student-2\" })\nMATCH (a:TestActivityModel3) WHERE a.actName IN [\"ITGD\", \"Neo4j\"]\nCREATE (s)-[:ATTENDS]->(a) ;\n```\n\n\n\n\n![Model 3](./images/cypher-clash3-model.png)\n\nThe results are the same as Model 1 and Model 2, but the profile is different again with even fewer `database accesses` (58):\n\n![Model 3 profile](./images/cypher-clash3-db-hits.png)\n\n\n### Model 4 - \n\nModel 4 uses a single node for each activity and date - start and end times are now properties of the *relationship* between the activity and the date.\n\n\n\n\n```{cypher .cypher-scroll}\n// Create unique date nodes\nMERGE (:TestDateNodeModel4 { date: date(\"2024-07-30\") })\nMERGE (:TestDateNodeModel4 { date: date(\"2024-08-06\") })\nMERGE (:TestDateNodeModel4 { date: date(\"2024-08-13\") })\nMERGE (:TestDateNodeModel4 { date: date(\"2024-08-20\") })\nMERGE (:TestDateNodeModel4 { date: date(\"2024-08-27\") })\nMERGE (:TestDateNodeModel4 { date: date(\"2024-09-03\") })\n\n// Create activity nodes \nMERGE (:TestActivityModel4 { actName: \"ITGD\" })\nMERGE (:TestActivityModel4 { actName: \"Neo4j\" })\nMERGE (:TestActivityModel4 { actName: \"TigerDb\" });\n\n// Connect ITGD to Dates with START and END relationships\nMATCH (a:TestActivityModel4 { actName: \"ITGD\" })\nMATCH (d:TestDateNodeModel4) WHERE d.date IN [date(\"2024-08-06\"), date(\"2024-08-13\"), date(\"2024-08-20\"), date(\"2024-08-27\"), date(\"2024-09-03\")]\nMERGE (a)-[:STARTS { time: localtime(\"09:00:00\") }]->(d)\nMERGE (a)-[:ENDS { time: localtime(\"11:00:00\") }]->(d);\n\n// Connect Neo4j to Dates (adjust dates and times)\nMATCH (a:TestActivityModel4 { actName: \"Neo4j\" })\nMATCH (d:TestDateNodeModel4) WHERE d.date IN [date(\"2024-07-30\"), date(\"2024-08-13\"), date(\"2024-08-27\")]\nMERGE (a)-[:STARTS { time: localtime(\"10:00:00\") }]->(d)\nMERGE (a)-[:ENDS { time: localtime(\"11:00:00\") }]->(d);\n\n// Connect TigerDb to Dates (adjust dates and times)\nMATCH (a:TestActivityModel4 { actName: \"TigerDb\" })\nMATCH (d:TestDateNodeModel4) WHERE d.date IN [date(\"2024-08-06\"), date(\"2024-08-13\")]\nMERGE (a)-[:STARTS { time: localtime(\"11:00:00\") }]->(d)\nMERGE (a)-[:ENDS { time: localtime(\"12:00:00\") }]->(d);\n\n// Create Students and ATTENDS relationships\nMERGE (:TestStudentModel4 { stuFirstName_anon: \"Alice\", stuID_anon: \"test-student-1\" })\nMERGE (:TestStudentModel4 { stuFirstName_anon: \"Bob\", stuID_anon: \"test-student-2\" });\n\nMATCH (s:TestStudentModel4 { stuID_anon: \"test-student-1\" })\nMATCH (a:TestActivityModel4) WHERE a.actName IN [\"TigerDb\", \"Neo4j\"]\nMERGE (s)-[:ATTENDS]->(a) ;\n\nMATCH (s:TestStudentModel4 { stuID_anon: \"test-student-2\" })\nMATCH (a:TestActivityModel4) WHERE a.actName IN [\"ITGD\", \"Neo4j\"]\nMERGE (s)-[:ATTENDS]->(a) ;\n```\n\n\n\n\n![Model 4](./images/cypher-clash4-model.png)\n\n\nThe results are again the same as Model 1, Model 2, and Model 3, but the profile is different with the most `database accesses` (293):\n\n![Model 4 profile](./images/cypher-clash4-db-hits.png)\n\n## Conclusion\n\nEach model has its own strengths and weaknesses.  The choice of model will depend on the specific requirements.  The more complex models can be more efficient for certain queries, but can also be more difficult to understand and maintain.  The simpler models are easier to understand and maintain, but can be less efficient for certain queries.\n\nOf the four tested, Model 3 was the most efficient in terms of database hits on the *very* small test dataset used.  However, this may not be the case with larger datasets.  It is important to profile the queries and the data to determine the best model for the specific requirements.\n\n## Delete Data\n\nThe cypher below deletes all test data. \n\n### Model 1\n\n```cypher\n// Delete all TestActivityModel1 nodes\nMATCH (a:TestActivityModel1)\nDETACH DELETE a; \n\n// Delete all TestStudentModel1 nodes\nMATCH (s:TestStudentModel1)\nDETACH DELETE s;\n```\n\n### Model 2\n\n```cypher\n// Delete test data for Model 2\nMATCH (n) \nWHERE n:TestStudentModel2 OR n:TestActivityModel2 OR n:TestDateNode OR n:TestStartTimeNode OR n:TestEndTimeNode\nDETACH DELETE n\n```\n\n### Model 3\n\n```cypher\n// Delete test data for Model 3\nMATCH (n) \nWHERE n:TestStudentModel3 OR n:TestActivityModel3 OR n:TestDateNodeModel3 \nDETACH DELETE n\n```\n\n### Model 4\n\n```cypher\nMATCH (n) \nWHERE n:TestStudentModel4 OR n:TestActivityModel4 OR n:TestDateNodeModel4\nDETACH DELETE n\n```\n\n",
    "supporting": [
      "appendix-cypher5a_files"
    ],
    "filters": [],
    "includes": {}
  }
}