{
  "hash": "6ced5dcf4bcb483b4a1a430c5ac7a78d",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Soft Constraints\"\nlightbox:\n  match: auto\n  effect: fade\n  desc-position: bottom\n  loop: false\n---\n\n\n\n\n\n\n<br>\nSoft constraints in a timetabling context are (strong) preferences. They should be generally met and only violated when absolutely necessary, although there is an argument for a sliding scale of soft constraint adherence.\n\nFor example, a member of staff may be unavailable on Fridays, generally, but at a push can be available. Other examples might include ensuring that students have an opportunity to eat lunch by ensuring at least 30 minutes free time between 12:00-14:00 or minimising travel between activities.\n\nThis page contains cypher queries that can be used to identify where a timetabling soft constraint has been violated.\n\nExample soft constraints include:\n\n-   **Minimal Idle Time (aka no large gaps):** Minimise gaps in staff and student schedules (within reason).\n-   **Spread Activities (aka maximum consecutive hours):** Avoid clumping all activities for a student or staff member on one day.\n-   **Preferred Times:** Consider staff and student preferences for morning, afternoon, or evening classes\n-   **Travel Time:** Minimise the time students need to travel between consecutive classes (especially on large campuses), e.g. between building blocks or by lat/long\n-   **Lunch Breaks:** Ensure students have sufficient time for lunch breaks.\n\n### Minimal idle time\n\nIdentifying time gaps between scheduled activities is very complex and requires several steps, clauses and comprehensions within a single query:\n\n* *grouping and sorting* - activities are grouped by student and date, and sorted within groups to establish the sequence\n* *gap calculation* - time difference between the end of one activity and the start of the next is calculated for consecutive pairs of activities within a day\n* *filtering and aggregation* - gaps are filtered based on threshold (e.g. 6 hours) and then the maximum gap for each day is identified\n* *data restructuring* - output is restructured.\n\n#### Cypher logic for identifying gaps\n\nThe below is the logic for identifying gaps between activities, using an example student: \n\n\n```{cypher}{.scroll-cypher}\nMATCH (s:student)-[:ATTENDS]->(a:activity)\nWHERE s.stuID_anon = \"stu-10085720\"\nAND a.actStartDate = date(\"2022-10-03\")\nWITH s, a\nORDER BY a.actStartTime\n\n// Collecting the start and end times of the activities\nWITH s, collect({start: a.actStartTime, end: a.actEndTime}) AS times\n\n// Calculating the gaps in minutes between consecutive activities\nWITH s, times, \n     [i IN range(0, size(times)-2) | \n      duration.between(times[i].end, times[i+1].start).minutes / 60.0] AS gaps\n\n// Finding the maximum gap\nRETURN s.stuID_anon AS student, times, gaps, reduce(maxGap = 0.0, gap IN gaps | CASE WHEN gap > maxGap THEN gap ELSE maxGap END) AS maxGap\n```\n\n\n![Example student with gaps between activities](./images/cypher-maxGap-example.png)\n\n\n#### Python code on graph\n\nThe below code cell returns the first 5 rows where a 6 hour maximum gap has been violated. \n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom connect_to_neo4j_db import connect_to_neo4j\nfrom neo4j import GraphDatabase\nimport pandas as pd\n\n# connect to Neo4j\ndriver = connect_to_neo4j()\n\n# session\nsession = driver.session()\n\n# run query (modified RETURN clause)\nquery = \"\"\"\n// students with gaps between activities\nMATCH (s:student)-[:ATTENDS]->(a:activity)\nWITH s, a\nORDER BY s.stuFirstName_anon, a.actStartDate, a.actStartTime\n// Group activities by student and date\nWITH s, a.actStartDate AS date, collect({start: a.actStartTime, end: a.actEndTime, activity: a}) AS times\n// calculating the gaps in hours between consecutive activities\nWITH s, date, times, \n     [i IN range(0, size(times)-2) | \n      {gap: duration.between(times[i].end, times[i+1].start).minutes / 60.0, \n       firstActivity: times[i].activity, \n       secondActivity: times[i+1].activity}] AS gaps\n// filtering gaps based on a threshold of 6 hours\nWITH s, date, gaps\nWHERE any(gapRecord IN gaps WHERE gapRecord.gap > 6.0)\n// Finding the maximum gap that exceeds the threshold\nWITH s, date, reduce(maxGap = {gap: 0.0, firstActivity: null, secondActivity: null}, gapRecord IN gaps | \n    CASE WHEN gapRecord.gap > maxGap.gap THEN gapRecord ELSE maxGap END) AS maxGapRecord\n// group by student to remove duplications\nWITH s.stuID_anon AS student, \n     collect({date: date, \n              activity1: maxGapRecord.firstActivity.actName,\n              activity1_time: maxGapRecord.firstActivity.actStartTime + \"-\" + maxGapRecord.firstActivity.actEndTime,\n              activity2: maxGapRecord.secondActivity.actName,\n              activity2_time: maxGapRecord.secondActivity.actStartTime + \"-\" + maxGapRecord.secondActivity.actEndTime,\n              maxGapInHours: maxGapRecord.gap}) AS gapRecords\n// Unwind the collected records\nUNWIND gapRecords AS record\n// Returning the result\nRETURN student, \n       record.date AS date,\n       record.activity1 AS activity1, \n       record.activity1_time AS activity1_time,\n       record.activity2 AS activity2,\n       record.activity2_time AS activity2_time,\n       record.maxGapInHours AS maxGapInHours\nORDER BY student, date\n\"\"\"\n\nprint(\"Running query...\\n\")\nresult = session.run(query)\n\n#  list to hold records\nrecords = []\nfor record in result:\n    records.append(record)\n\n# df\ndf = pd.DataFrame(records, columns=[\"student\", \"date\", \"activity1\", \"activity1_time\", \n                                   \"activity2\", \"activity2_time\", \"maxGapInHours\"])\n\n# print \nprint(df.head(5))\n\n# close session and driver\nsession.close()\ndriver.close()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nConnecting to Neo4j database....\nConnected to Neo4j database successfully! Driver: <neo4j._sync.driver.Neo4jDriver object at 0x000001B61F23E750>\nRunning query...\n\n        student        date                 activity1     activity1_time  \\\n0  stu-10270089  2023-01-30  UFCFGS-15-1 L_oc/01 <29>  09:00:00-10:00:00   \n1  stu-10270089  2023-02-06  UFCFGS-15-1 L_oc/01 <30>  09:00:00-10:00:00   \n2  stu-10270089  2023-02-13  UFCFGS-15-1 L_oc/01 <31>  09:00:00-10:00:00   \n3  stu-10270089  2023-02-20  UFCFGS-15-1 L_oc/01 <32>  09:00:00-10:00:00   \n4  stu-10270089  2023-02-27  UFCFGS-15-1 L_oc/01 <33>  09:00:00-10:00:00   \n\n                   activity2     activity2_time  maxGapInHours  \n0  UFCFES-30-1 L2_oc/01 <29>  17:30:00-19:00:00            7.5  \n1  UFCFES-30-1 L2_oc/01 <30>  17:30:00-19:00:00            7.5  \n2  UFCFES-30-1 L2_oc/01 <31>  17:30:00-19:00:00            7.5  \n3  UFCFES-30-1 L2_oc/01 <32>  17:30:00-19:00:00            7.5  \n4  UFCFES-30-1 L2_oc/01 <33>  17:30:00-19:00:00            7.5  \n```\n:::\n:::\n\n\n#### Python to return total hours and block hours\n\nAlternatively, we can amend the query to return, for each date and student combination, their total scheduled hours, maximum consecutive block hours and the number of activities within the continuous block. \n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nfrom connect_to_neo4j_db import connect_to_neo4j\nfrom neo4j import GraphDatabase\nimport pandas as pd\n\n# connect to Neo4j\ndriver = connect_to_neo4j()\n\n# session\nsession = driver.session()\n\n# run query (modified RETURN clause)\nquery = \"\"\"\n// calculates - total hours, max block hours, max block activities per day \n// to be used for max block hours and max block activities per day\n// logic - example\n\n// matches specified student and all attended activities\nMATCH (s:student {stuID_anon:\"stu-10085720\"})-[:ATTENDS]->(a:activity)\n\n// sorts activities by start date and then by start time within each date\nWITH s, a ORDER BY a.actStartDate, a.actStartTime\n\n// calculates total hours spent on activities for each date\nWITH s, a.actStartDate AS date, \n     SUM(a.actDurationInMinutes) / 60.0 AS totalHours,\n     // groups activities into blocks based on time overlaps\n     REDUCE(\n        blockInfo = [],\n        activity IN COLLECT(a)\n        | CASE\n            WHEN blockInfo = [] THEN [[activity]]\n            ELSE CASE\n                   WHEN head(last(blockInfo)).actEndTime >= activity.actStartTime\n                     THEN blockInfo[..-1] + [last(blockInfo) + activity]\n                   ELSE blockInfo + [[activity]]\n                 END\n          END\n     ) AS blocks\n\n// unwinds the list of blocks, processing each block individually\nUNWIND blocks AS block\n\n// calculates the total duration in hours for each block\nWITH s, date, totalHours, blocks,\n     REDUCE(blockHours = 0.0, activity IN block | blockHours + activity.actDurationInMinutes) / 60.0 AS blockHours,\n     SIZE(block) AS blockActivities\n\n// returns aggregated results\nRETURN s.stuFullName_anon AS student, date, totalHours, \n       MAX(blockHours) AS blockHours,\n       MAX(blockActivities) AS blockActivities\nORDER BY date;\n\"\"\"\n\nprint(\"Running query...\\n\")\nresult = session.run(query)\n\n#  list to hold records\nrecords = []\nfor record in result:\n    records.append(record)\n\n# df\ndf = pd.DataFrame(records, columns=[\"student\", \"date\", \"totalHours\", \"blockHours\", \"blockActivities\"])\n\n# print \nprint(df.head(5))\n\n# close session and driver\nsession.close()\ndriver.close()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nConnecting to Neo4j database....\nConnected to Neo4j database successfully! Driver: <neo4j._sync.driver.Neo4jDriver object at 0x000001B622E13350>\nRunning query...\n\n       student        date  totalHours  blockHours  blockActivities\n0  Aaron Evans  2022-09-22         1.0         1.0                1\n1  Aaron Evans  2022-09-23         2.0         2.0                1\n2  Aaron Evans  2022-09-27         2.0         2.0                2\n3  Aaron Evans  2022-09-30         4.0         2.0                2\n4  Aaron Evans  2022-10-03         4.5         2.5                2\n```\n:::\n:::\n\n\n#### Example Use case - identifying students with 5+ hours in a single block\n\nThis query returns the first five rows where a student has more than 5 consecutive scheduled hours on a date. \n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nfrom connect_to_neo4j_db import connect_to_neo4j\nfrom neo4j import GraphDatabase\nimport pandas as pd\n\n# connect to Neo4j\ndriver = connect_to_neo4j()\n\n# session\nsession = driver.session()\n\n# run query (modified RETURN clause)\nquery = \"\"\"\nMATCH (s:student)-[:ATTENDS]->(a:activity)<-[:TEACHES]-(:staff) // Filter for teaching activities\nWITH s, a ORDER BY a.actStartDate, a.actStartTime\nWITH s, a.actStartDate AS date, \n     SUM(a.actDurationInMinutes) / 60.0 AS totalHours,\n     REDUCE(\n         blockInfo = [],\n         activity IN COLLECT(a)\n         | CASE\n             WHEN blockInfo = [] THEN [[activity]]\n             ELSE CASE\n                     WHEN head(last(blockInfo)).actEndTime >= activity.actStartTime\n                         THEN blockInfo[..-1] + [last(blockInfo) + activity]\n                     ELSE blockInfo + [[activity]]\n                 END\n         END\n     ) AS blocks\nUNWIND blocks AS block\nWITH s, date, totalHours, blocks,\n     REDUCE(blockHours = 0.0, activity IN block | blockHours + activity.actDurationInMinutes) / 60.0 AS blockHours,\n     SIZE(block) AS blockActivities\nWHERE blockHours > 5 // Filter for blocks with more than 5 hours\nRETURN s.stuFullName_anon AS student, date, totalHours, \n       blockHours,\n       blockActivities\nORDER BY date;\n\"\"\"\n\nprint(\"Running query...\\n\")\nresult = session.run(query)\n\n#  list to hold records\nrecords = []\nfor record in result:\n    records.append(record)\n\n# df\ndf = pd.DataFrame(records, columns=[\"student\", \"date\", \"totalHours\", \"blockHours\", \"blockActivities\"])\n\n# print \nprint(df.head(5))\n\n# close session and driver\nsession.close()\ndriver.close()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nConnecting to Neo4j database....\nConnected to Neo4j database successfully! Driver: <neo4j._sync.driver.Neo4jDriver object at 0x000001B622A10190>\nRunning query...\n\n             student        date  totalHours  blockHours  blockActivities\n0        Jacob Jones  2022-07-19         5.5         5.5                2\n1      Rachael Moore  2022-07-19         5.5         5.5                2\n2        Kayla Sharp  2022-07-19         5.5         5.5                2\n3         David Rose  2022-07-19         5.5         5.5                2\n4  Francisco Holland  2022-07-19         5.5         5.5                2\n```\n:::\n:::\n\n\n#### Total hours per day\n\nIn contrast, calculating simple total hours per day is achieved by: \n\n```{cypher}{.scroll-cypher}\nMATCH (s:student )-[:ATTENDS]->(a:activity)\nWITH s, a.actStartDate AS Date, SUM(a.actDurationInMinutes) / 60.0 AS totalHours\nRETURN s.stuFullName_anon AS Student, Date, totalHours\nORDER BY Date;\n```\n\n![Total hours per day](./images/cypher-hoursPerDay.png)\n\n#### Longest consecutive block of activities per day\n\nWe can use the earlier cypher logic to identify the longest consecutive block of activities for a student, or student on a day, etc. \n\n```{cypher}{.scroll-cypher}\n\nMATCH (s:student {stuFullName_anon: \"Susan Lopez\"})-[:ATTENDS]->(a:activity {actStartDate: date(\"2022-09-27\")})\nWITH s, a \nORDER BY a.actStartTime\nWITH s, COLLECT(a) AS activities\nWITH s, activities,\n     REDUCE(\n       state = {currentBlock: {duration: 0, start: null, end: null}, longestBlock: {duration: 0, start: null, end: null}},\n       activity IN activities |\n         CASE\n           WHEN state.currentBlock.end IS NULL OR \n                activity.actStartTime > state.currentBlock.end\n           THEN {\n             currentBlock: {\n               duration: activity.actDurationInMinutes,\n               start: activity.actStartTime,\n               end: activity.actEndTime\n             },\n             longestBlock: \n               CASE\n                 WHEN activity.actDurationInMinutes > state.longestBlock.duration\n                 THEN {\n                   duration: activity.actDurationInMinutes,\n                   start: activity.actStartTime,\n                   end: activity.actEndTime\n                 }\n                 ELSE state.longestBlock\n               END\n           }\n           ELSE {\n             currentBlock: {\n               duration: (activity.actEndTime.hour * 60 + activity.actEndTime.minute) - \n                         (state.currentBlock.start.hour * 60 + state.currentBlock.start.minute),\n               start: state.currentBlock.start,\n               end: activity.actEndTime\n             },\n             longestBlock: \n               CASE\n                 WHEN ((activity.actEndTime.hour * 60 + activity.actEndTime.minute) - \n                       (state.currentBlock.start.hour * 60 + state.currentBlock.start.minute)) > state.longestBlock.duration\n                 THEN {\n                   duration: (activity.actEndTime.hour * 60 + activity.actEndTime.minute) - \n                             (state.currentBlock.start.hour * 60 + state.currentBlock.start.minute),\n                   start: state.currentBlock.start,\n                   end: activity.actEndTime\n                 }\n                 ELSE state.longestBlock\n               END\n           }\n         END\n     ) AS finalState\nRETURN\n  s.stuFullName_anon AS stuName,\n  activities[0].actStartDate AS date,\n  finalState.longestBlock.duration AS longestConsecutiveBlockDuration,\n  finalState.longestBlock.start AS blockStartTime,\n  finalState.longestBlock.end AS blockEndTime\n```\n\n#### Example - longest consecutive block for 'Susan Lopez' on 2022-09-27\n\nThe below finds the longest consecutive block in a day for a student:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nfrom connect_to_neo4j_db import connect_to_neo4j\nfrom neo4j import GraphDatabase\nimport pandas as pd\n\n# connect to Neo4j\ndriver = connect_to_neo4j()\n\n# session\nsession = driver.session()\n\n# run query (modified RETURN clause)\nquery = \"\"\"\nMATCH (s:student {stuFullName_anon: \"Susan Lopez\"})-[:ATTENDS]->(a:activity{actStartDate: date(\"2022-09-27\")})\nWITH s, a \nORDER BY a.actStartTime\nWITH s, COLLECT(a) AS activities\nWITH s, activities,\n   REDUCE(\n     state = {currentBlock: {duration: 0, start: null, end: null}, longestBlock: {duration: 0, start: null, end: null}},\n     activity IN activities |\n       CASE\n         WHEN state.currentBlock.end IS NULL OR \n              activity.actStartTime > state.currentBlock.end\n         THEN {\n           currentBlock: {\n             duration: activity.actDurationInMinutes,\n             start: activity.actStartTime,\n             end: activity.actEndTime\n           },\n           longestBlock: \n             CASE\n               WHEN activity.actDurationInMinutes > state.longestBlock.duration\n               THEN {\n                 duration: activity.actDurationInMinutes,\n                 start: activity.actStartTime,\n                 end: activity.actEndTime\n               }\n               ELSE state.longestBlock\n             END\n         }\n         ELSE {\n           currentBlock: {\n             duration: (activity.actEndTime.hour * 60 + activity.actEndTime.minute) - \n                       (state.currentBlock.start.hour * 60 + state.currentBlock.start.minute),\n             start: state.currentBlock.start,\n             end: activity.actEndTime\n           },\n           longestBlock: \n             CASE\n               WHEN ((activity.actEndTime.hour * 60 + activity.actEndTime.minute) - \n                     (state.currentBlock.start.hour * 60 + state.currentBlock.start.minute)) > state.longestBlock.duration\n               THEN {\n                 duration: (activity.actEndTime.hour * 60 + activity.actEndTime.minute) - \n                           (state.currentBlock.start.hour * 60 + state.currentBlock.start.minute),\n                 start: state.currentBlock.start,\n                 end: activity.actEndTime\n               }\n               ELSE state.longestBlock\n             END\n         }\n       END\n   ) AS finalState\nRETURN\ns.stuFullName_anon AS student,\nactivities[0].actStartDate AS date,\nfinalState.longestBlock.duration AS longestConsecutiveBlockDuration,\nfinalState.longestBlock.start AS blockStartTime,\nfinalState.longestBlock.end AS blockEndTime\n\"\"\"\n\nprint(\"Running query...\\n\")\nresult = session.run(query)\n\n#  list to hold records\nrecords = []\nfor record in result:\n  records.append(record)\n\n# df\ndf = pd.DataFrame(records, columns=[\"student\", \"date\", \"longestConsecutiveBlockDuration\", \"blockStartTime\", \"blockEndTime\"])\n\n# print \nprint(df.head(5))\n\n# close session and driver\nsession.close()\ndriver.close()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nConnecting to Neo4j database....\nConnected to Neo4j database successfully! Driver: <neo4j._sync.driver.Neo4jDriver object at 0x000001B622A2D1D0>\nRunning query...\n\n       student        date  longestConsecutiveBlockDuration  \\\n0  Susan Lopez  2022-09-27                              300   \n\n       blockStartTime        blockEndTime  \n0  13:00:00.000000000  18:00:00.000000000  \n```\n:::\n:::\n\n\n### Max hours in a day\n\nThis query calculates the total scheduled hours for each student on a day and returns the results ordered by date. This example filters for students who have more than 7 hours of activities in a day.\n\n```{cypher}{.scroll-cypher}\n// sum of activity durations\n// does not account for simultaneous activities (clashes) - so could be inflated, e.g. 12.5 hour students\n\nMATCH (s:student)-[:ATTENDS]->(a:activity)\nWITH s, a.actStartDate AS Date, SUM(a.actDurationInMinutes) / 60.0 AS totalHours\nWHERE totalHours > 7 // Set  maximum here\nRETURN s.stuFullName_anon AS Student, Date, totalHours\nORDER BY Date;\n```\n\n![Max hours in a day](./images/cypher-maxTotalDay.png)\n\n\n### Travel time between activities\n\nThis query calculates the travel time between consecutive activities for a student on a specific date. It uses the lat/long coordinates of the buildings to calculate the distance and time taken to travel between them and a default walking speed of 1.4 m/s to calculate time.  \n\nThis is a simple example and does not account for factors like traffic, walking speed, or other modes of transport.\n\n\n```{cypher}{.scroll-cypher}\n// Calculate travel time between consecutive activities for a student on a specific date\nMATCH (s:student {stuFullName_anon: \"David Johnson\"})-[:ATTENDS]->(a1:activity)-[:OCCUPIES]->(r1:room),\n      (s)-[:ATTENDS]->(a2:activity)-[:OCCUPIES]->(r2:room)\nWHERE a1.actEndTime = a2.actStartTime AND a1.actStartDate = a2.actStartDate AND a1 <> a2 AND\n      a1.actStartDate IN [date(\"2023-01-11\"), date(\"2022-09-27\"), date(\"2023-03-14\")] \nRETURN DISTINCT \n    s.stuFullName_anon, \n    a1.actName AS act1, a1.actStartDate AS date, a1.actStartTime+\"-\"+a1.actEndTime AS act1Times, a2.actStartTime+\"-\"+a2.actEndTime AS act2Times, a2.actName AS act2,\n    point.distance(r1.location, r2.location) AS distance,\n    round(point.distance(r1.location, r2.location) / 1.4) AS walkingTimeSeconds // Calculate walking time in seconds\n```\n\n![Travel time between activities](./images/cypher-b2b-travel.png)\n\n### Lunch breaks\n\nIt might be expected that a student (or staff) has a lunch break.  The cypher below calculates free and booked tie within a window, in this case 12:00 and 14:00.  It can be used to find students who do not have a lunch break or count the number of days that a student does not have a lunch break.  \n\n```{cypher}{.scroll-cypher}\n\nMATCH (s:student)-[:ATTENDS]->(a:activity)\nWITH s, a\nORDER BY a.actStartDate, a.actStartTime\nWITH s, COLLECT(a) AS activities\nUNWIND activities AS activity\nWITH s.stuFullName_anon AS Student, activity.actStartDate AS Date, time(activity.actStartTime) AS StartTime, time(activity.actEndTime) AS EndTime, duration.between(time('12:00'), time('14:00')).minutes AS BreakWindow_12_14\nWITH Student, Date, BreakWindow_12_14, COLLECT([StartTime, EndTime]) AS Activities\nUNWIND Activities AS activity\nWITH Student, Date, BreakWindow_12_14, activity[0] AS StartTime, activity[1] AS EndTime\nWITH Student, Date, BreakWindow_12_14,\n     CASE\n       WHEN StartTime >= time('14:00') OR EndTime <= time('12:00') THEN 0\n       WHEN StartTime < time('12:00') AND EndTime > time('14:00') THEN BreakWindow_12_14\n       WHEN StartTime >= time('12:00') AND StartTime < time('14:00') THEN duration.between(StartTime, time('14:00')).minutes\n       WHEN EndTime > time('12:00') AND EndTime <= time('14:00') THEN duration.between(time('12:00'), EndTime).minutes\n     END AS BookedDurationMinutes\nRETURN Student, Date, BreakWindow_12_14, BreakWindow_12_14 - SUM(BookedDurationMinutes) AS FreeTimeMinutes, SUM(BookedDurationMinutes) AS BookedTimeMinutes\nORDER BY Date\n```\n\n![Lunch breaks](./images/cypher-lunchBreak.png)\n\nInterestingly, `Michael Johnson` has a negative lunch break! A quick look showed that there are actually two `Michael Johnsons` attending this class and they both have 30 minutes free time in the 2-hour lunch break window.\n\nBecause the query was written using student name, it is incorrectly aggregating the two students into one person as follows:\n\n$$\n2 \\text{ hour lunch window} - (1.5 \\text{ hours/class} \\times 2 \\text{ students}) = -1 \\text{ hour}\n$$\n\nTo remedy this, the query can be updated to use student ID or a different unique identifier.  I would also like to update the anonymisation function in the ETL so that it does not duplicate names in the output. \n\n",
    "supporting": [
      "appendix-cypher6_files\\figure-docx"
    ],
    "filters": []
  }
}