{
  "hash": "fa029c08f64e22bee57158a0ee7c2480",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Soft Constraints\"\nlightbox:\n  match: auto\n  effect: fade\n  desc-position: bottom\n  loop: false\n---\n\n\n\n\n<br>\n\nSoft constraints in a timetabling context can be considered to be (strong) preferences. They should be generally met and only violated when absolutely necessary.\n\nFor example, a member of staff may be unavailable on Fridays, generally, but at a push can be available. Other examples might include ensuring that students have an opportunity to eat lunch or minimising travel between distant locations.\n\nThis page contains cypher queries that can be used to identify where a timetabling soft constraint has been violated.\n\nExample soft constraints include:\n\n-   **Minimal Idle Time (aka no large gaps):** Minimise gaps in staff and student schedules (within reason).\n-   **Spread Activities (aka maximum consecutive hours):** Avoid clumping all activities for a student or staff member on one day.\n-   **Preferred Times:** Consider staff and student preferences for morning, afternoon, or evening classes\n-   **Travel Time:** Minimise the time students need to travel between consecutive classes (especially on large campuses), e.g. between building blocks or by lat/long\n-   **Lunch Breaks:** Ensure students have sufficient time for lunch breaks.\n\n### Minimal idle time\n\n::: {#3255d989 .cell execution_count=1}\n``` {.python .cell-code}\nfrom connect_to_neo4j_db import connect_to_neo4j\nfrom neo4j import GraphDatabase\nimport pandas as pd\n\n# connect to Neo4j\ndriver = connect_to_neo4j()\n\n# session\nsession = driver.session()\n\n# run query (modified RETURN clause)\nquery = \"\"\"\n// students with gaps between activities\nMATCH (s:student)-[:ATTENDS]->(a:activity)\nWITH s, a\nORDER BY s.stuFirstName_anon, a.actStartDate, a.actStartTime\n// Group activities by student and date\nWITH s, a.actStartDate AS date, collect({start: a.actStartTime, end: a.actEndTime, activity: a}) AS times\n// Calculating the gaps in hours between consecutive activities\nWITH s, date, times, \n     [i IN range(0, size(times)-2) | \n      {gap: duration.between(times[i].end, times[i+1].start).minutes / 60.0, \n       firstActivity: times[i].activity, \n       secondActivity: times[i+1].activity}] AS gaps\n// Filtering gaps based on a threshold of 6 hours\nWITH s, date, gaps\nWHERE any(gapRecord IN gaps WHERE gapRecord.gap > 6.0)\n// Finding the maximum gap that exceeds the threshold\nWITH s, date, reduce(maxGap = {gap: 0.0, firstActivity: null, secondActivity: null}, gapRecord IN gaps | \n    CASE WHEN gapRecord.gap > maxGap.gap THEN gapRecord ELSE maxGap END) AS maxGapRecord\n// Group by student to remove duplications\nWITH s.stuID_anon AS student, \n     collect({date: date, \n              activity1: maxGapRecord.firstActivity.actName,\n              activity1_time: maxGapRecord.firstActivity.actStartTime + \"-\" + maxGapRecord.firstActivity.actEndTime,\n              activity2: maxGapRecord.secondActivity.actName,\n              activity2_time: maxGapRecord.secondActivity.actStartTime + \"-\" + maxGapRecord.secondActivity.actEndTime,\n              maxGapInHours: maxGapRecord.gap}) AS gapRecords\n// Unwind the collected records\nUNWIND gapRecords AS record\n// Returning the result\nRETURN student, \n       record.date AS date,\n       record.activity1 AS activity1, \n       record.activity1_time AS activity1_time,\n       record.activity2 AS activity2,\n       record.activity2_time AS activity2_time,\n       record.maxGapInHours AS maxGapInHours\nORDER BY student, date\n\"\"\"\n\nprint(\"Running query...\\n\")\nresult = session.run(query)\n\n#  list to hold records\nrecords = []\nfor record in result:\n    records.append(record)\n\n# df\ndf = pd.DataFrame(records, columns=[\"student\", \"date\", \"activity1\", \"activity1_time\", \n                                   \"activity2\", \"activity2_time\", \"maxGapInHours\"])\n\n# print \nprint(df.head(5))\n\n# close session and driver\nsession.close()\ndriver.close()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nConnecting to Neo4j database....\nConnected to Neo4j database successfully! Driver: <neo4j._sync.driver.Neo4jDriver object at 0x00000244F2DA3A50>\nRunning query...\n\n        student        date                 activity1     activity1_time  \\\n0  stu-10270089  2023-01-30  UFCFGS-15-1 L_oc/01 <29>  09:00:00-10:00:00   \n1  stu-10270089  2023-02-06  UFCFGS-15-1 L_oc/01 <30>  09:00:00-10:00:00   \n2  stu-10270089  2023-02-13  UFCFGS-15-1 L_oc/01 <31>  09:00:00-10:00:00   \n3  stu-10270089  2023-02-20  UFCFGS-15-1 L_oc/01 <32>  09:00:00-10:00:00   \n4  stu-10270089  2023-02-27  UFCFGS-15-1 L_oc/01 <33>  09:00:00-10:00:00   \n\n                   activity2     activity2_time  maxGapInHours  \n0  UFCFES-30-1 L2_oc/01 <29>  17:30:00-19:00:00            7.5  \n1  UFCFES-30-1 L2_oc/01 <30>  17:30:00-19:00:00            7.5  \n2  UFCFES-30-1 L2_oc/01 <31>  17:30:00-19:00:00            7.5  \n3  UFCFES-30-1 L2_oc/01 <32>  17:30:00-19:00:00            7.5  \n4  UFCFES-30-1 L2_oc/01 <33>  17:30:00-19:00:00            7.5  \n```\n:::\n:::\n\n\n``` cypher\nMATCH (s:student)-[:ATTENDS]->(a:activity)\nWHERE s.stuID_anon = \"stu-10085720\"\nAND a.actStartDate = date(\"2022-10-03\")\nWITH s, a\nORDER BY a.actStartTime\n\n// Collecting the start and end times of the activities\nWITH s, collect({start: a.actStartTime, end: a.actEndTime}) AS times\n\n// Calculating the gaps in minutes between consecutive activities\nWITH s, times, \n     [i IN range(0, size(times)-2) | \n      duration.between(times[i].end, times[i+1].start).minutes / 60.0] AS gaps\n\n// Finding the maximum gap\nRETURN s.stuID_anon AS student, times, gaps, reduce(maxGap = 0.0, gap IN gaps | CASE WHEN gap > maxGap THEN gap ELSE maxGap END) AS maxGap\n```\n\nThe above query illustrates the logic for identifying gaps between activities with the following results for an example student:\n\n![Example student with gaps between activities](./images/cypher-maxGap-example.png)\n\n::: {#7724f441 .cell execution_count=2}\n``` {.python .cell-code}\nfrom connect_to_neo4j_db import connect_to_neo4j\nfrom neo4j import GraphDatabase\nimport pandas as pd\n\n# connect to Neo4j\ndriver = connect_to_neo4j()\n\n# session\nsession = driver.session()\n\n# run query (modified RETURN clause)\nquery = \"\"\"\n// Calculates - total hours, max block hours, max block activities per day \n// to be used for max block hours and max block activities per day\n// logic - example\n\nMATCH (s:student {stuID_anon:\"stu-10085720\"})-[:ATTENDS]->(a:activity)\nWITH s, a ORDER BY a.actStartDate, a.actStartTime\nWITH s, a.actStartDate AS date, \n     SUM(a.actDurationInMinutes) / 60.0 AS totalHours,\n     REDUCE(\n        blockInfo = [],\n        activity IN COLLECT(a)\n        | CASE\n            WHEN blockInfo = [] THEN [[activity]]\n            ELSE CASE\n                   WHEN head(last(blockInfo)).actEndTime >= activity.actStartTime\n                     THEN blockInfo[..-1] + [last(blockInfo) + activity]\n                   ELSE blockInfo + [[activity]]\n                 END\n          END\n     ) AS blocks\nUNWIND blocks AS block\nWITH s, date, totalHours, blocks,\n     REDUCE(blockHours = 0.0, activity IN block | blockHours + activity.actDurationInMinutes) / 60.0 AS blockHours,\n     SIZE(block) AS blockActivities\nRETURN s.stuFullName_anon AS student, date, totalHours, \n       MAX(blockHours) AS blockHours,\n       MAX(blockActivities) AS blockActivities\nORDER BY date;\n\"\"\"\n\nprint(\"Running query...\\n\")\nresult = session.run(query)\n\n#  list to hold records\nrecords = []\nfor record in result:\n    records.append(record)\n\n# df\ndf = pd.DataFrame(records, columns=[\"student\", \"date\", \"totalHours\", \"blockHours\", \"blockActivities\"])\n\n# print \nprint(df.head(5))\n\n# close session and driver\nsession.close()\ndriver.close()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nConnecting to Neo4j database....\nConnected to Neo4j database successfully! Driver: <neo4j._sync.driver.Neo4jDriver object at 0x00000244F6402E90>\nRunning query...\n\n       student        date  totalHours  blockHours  blockActivities\n0  Aaron Evans  2022-09-22         1.0         1.0                1\n1  Aaron Evans  2022-09-23         2.0         2.0                1\n2  Aaron Evans  2022-09-27         2.0         2.0                2\n3  Aaron Evans  2022-09-30         4.0         2.0                2\n4  Aaron Evans  2022-10-03         4.5         2.5                2\n```\n:::\n:::\n\n\n### Explanation\n\n1.  Match and Sort Activities:\n\n-   MATCH (s:student {stuID_anon:\"stu-10085720\"})-\\[:ATTENDS\\]-\\>(a:activity): Matches the specified student and all their attended activities.\n-   WITH s, a ORDER BY a.actStartDate, a.actStartTime: Sorts the activities by their start date and then by their start time within each date.\n\n2.  Calculate Total Hours and Group Activities into Blocks:\n\n-   WITH s, a.actStartDate AS Date, SUM(a.actDurationInMinutes) / 60.0 AS totalHours, ...: Calculates the total hours spent on activities for each date by summing the durations of all activities on that date and converting minutes to hours.\n-   REDUCE(blockInfo = \\[\\], activity IN COLLECT(a) \\| ...): Groups activities into blocks based on time overlaps using a REDUCE function and a CASE expression.\n    -   It initialises an empty list blockInfo to store the blocks.\n    -   It iterates over the collected activities (COLLECT(a)).\n    -   For each activity:\n        -   If blockInfo is empty (first activity), it creates a new block with the activity.\n        -   Otherwise, it checks if the current activity overlaps with the last activity in the last block of blockInfo.\n            -   If there's an overlap, it adds the current activity to the last block.\n            -   If there's no overlap, it creates a new block with the current activity.\n\n3.  Calculate Block Hours and Number of Activities:\n\n-   UNWIND blocks AS block: Unwinds the list of blocks, processing each block individually.\n-   WITH s, Date, totalHours, blocks, REDUCE(blockHours = 0.0, activity IN block \\| blockHours + activity.actDurationInMinutes) / 60.0 AS blockHours, SIZE(block) AS blockActivities: For each block, it calculates the total duration in hours (blockHours) by summing the durations of activities within the block and converting minutes to hours. It also calculates the number of activities in the block (blockActivities).\n\n4.  Return Aggregated Results:\n\n-   RETURN s.stuFullName_anon AS Student, Date, totalHours, MAX(blockHours) AS blockHours, MAX(blockActivities) AS blockActivities ORDER BY Date;: Returns the student's full name, the date, the total hours for the day, the maximum block hours across all blocks for that day, and the maximum number of activities within a single block for that day. The results are ordered by date.\n\n### Use case - more than 5 hours of activities in a single block\n\n::: {#7d0212c3 .cell execution_count=3}\n``` {.python .cell-code}\nfrom connect_to_neo4j_db import connect_to_neo4j\nfrom neo4j import GraphDatabase\nimport pandas as pd\n\n# connect to Neo4j\ndriver = connect_to_neo4j()\n\n# session\nsession = driver.session()\n\n# run query (modified RETURN clause)\nquery = \"\"\"\nMATCH (s:student)-[:ATTENDS]->(a:activity)<-[:TEACHES]-(:staff) // Filter for teaching activities\nWITH s, a ORDER BY a.actStartDate, a.actStartTime\nWITH s, a.actStartDate AS date, \n     SUM(a.actDurationInMinutes) / 60.0 AS totalHours,\n     REDUCE(\n         blockInfo = [],\n         activity IN COLLECT(a)\n         | CASE\n             WHEN blockInfo = [] THEN [[activity]]\n             ELSE CASE\n                     WHEN head(last(blockInfo)).actEndTime >= activity.actStartTime\n                         THEN blockInfo[..-1] + [last(blockInfo) + activity]\n                     ELSE blockInfo + [[activity]]\n                 END\n         END\n     ) AS blocks\nUNWIND blocks AS block\nWITH s, date, totalHours, blocks,\n     REDUCE(blockHours = 0.0, activity IN block | blockHours + activity.actDurationInMinutes) / 60.0 AS blockHours,\n     SIZE(block) AS blockActivities\nWHERE blockHours > 5 // Filter for blocks with more than 5 hours\nRETURN s.stuFullName_anon AS student, date, totalHours, \n       blockHours,\n       blockActivities\nORDER BY date;\n\"\"\"\n\nprint(\"Running query...\\n\")\nresult = session.run(query)\n\n#  list to hold records\nrecords = []\nfor record in result:\n    records.append(record)\n\n# df\ndf = pd.DataFrame(records, columns=[\"student\", \"date\", \"totalHours\", \"blockHours\", \"blockActivities\"])\n\n# print \nprint(df.head(5))\n\n# close session and driver\nsession.close()\ndriver.close()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nConnecting to Neo4j database....\nConnected to Neo4j database successfully! Driver: <neo4j._sync.driver.Neo4jDriver object at 0x00000244F5FF7610>\nRunning query...\n\n             student        date  totalHours  blockHours  blockActivities\n0        Jacob Jones  2022-07-19         5.5         5.5                2\n1      Rachael Moore  2022-07-19         5.5         5.5                2\n2        Kayla Sharp  2022-07-19         5.5         5.5                2\n3         David Rose  2022-07-19         5.5         5.5                2\n4  Francisco Holland  2022-07-19         5.5         5.5                2\n```\n:::\n:::\n\n\n### Total hours per day\n\n```cypher\nMATCH (s:student )-[:ATTENDS]->(a:activity)\nWITH s, a.actStartDate AS Date, SUM(a.actDurationInMinutes) / 60.0 AS totalHours\nRETURN s.stuFullName_anon AS Student, Date, totalHours\nORDER BY Date;\n```\n\n![Total hours per day](./images/cypher-hoursPerDay.png)\n\n### Longest consecutive block of activities per day\n\n```cypher\n\nMATCH (s:student {stuFullName_anon: \"Susan Lopez\"})-[:ATTENDS]->(a:activity {actStartDate: date(\"2022-09-27\")})\nWITH s, a \nORDER BY a.actStartTime\nWITH s, COLLECT(a) AS activities\nWITH s, activities,\n     REDUCE(\n       state = {currentBlock: {duration: 0, start: null, end: null}, longestBlock: {duration: 0, start: null, end: null}},\n       activity IN activities |\n         CASE\n           WHEN state.currentBlock.end IS NULL OR \n                activity.actStartTime > state.currentBlock.end\n           THEN {\n             currentBlock: {\n               duration: activity.actDurationInMinutes,\n               start: activity.actStartTime,\n               end: activity.actEndTime\n             },\n             longestBlock: \n               CASE\n                 WHEN activity.actDurationInMinutes > state.longestBlock.duration\n                 THEN {\n                   duration: activity.actDurationInMinutes,\n                   start: activity.actStartTime,\n                   end: activity.actEndTime\n                 }\n                 ELSE state.longestBlock\n               END\n           }\n           ELSE {\n             currentBlock: {\n               duration: (activity.actEndTime.hour * 60 + activity.actEndTime.minute) - \n                         (state.currentBlock.start.hour * 60 + state.currentBlock.start.minute),\n               start: state.currentBlock.start,\n               end: activity.actEndTime\n             },\n             longestBlock: \n               CASE\n                 WHEN ((activity.actEndTime.hour * 60 + activity.actEndTime.minute) - \n                       (state.currentBlock.start.hour * 60 + state.currentBlock.start.minute)) > state.longestBlock.duration\n                 THEN {\n                   duration: (activity.actEndTime.hour * 60 + activity.actEndTime.minute) - \n                             (state.currentBlock.start.hour * 60 + state.currentBlock.start.minute),\n                   start: state.currentBlock.start,\n                   end: activity.actEndTime\n                 }\n                 ELSE state.longestBlock\n               END\n           }\n         END\n     ) AS finalState\nRETURN\n  s.stuFullName_anon AS stuName,\n  activities[0].actStartDate AS date,\n  finalState.longestBlock.duration AS longestConsecutiveBlockDuration,\n  finalState.longestBlock.start AS blockStartTime,\n  finalState.longestBlock.end AS blockEndTime\n```\n\n\nThe below finds the longest consecutive block in a day for a student:\n\n::: {#b83be298 .cell execution_count=4}\n``` {.python .cell-code}\nfrom connect_to_neo4j_db import connect_to_neo4j\nfrom neo4j import GraphDatabase\nimport pandas as pd\n\n# connect to Neo4j\ndriver = connect_to_neo4j()\n\n# session\nsession = driver.session()\n\n# run query (modified RETURN clause)\nquery = \"\"\"\nMATCH (s:student {stuFullName_anon: \"Susan Lopez\"})-[:ATTENDS]->(a:activity{actStartDate: date(\"2022-09-27\")})\nWITH s, a \nORDER BY a.actStartTime\nWITH s, COLLECT(a) AS activities\nWITH s, activities,\n   REDUCE(\n     state = {currentBlock: {duration: 0, start: null, end: null}, longestBlock: {duration: 0, start: null, end: null}},\n     activity IN activities |\n       CASE\n         WHEN state.currentBlock.end IS NULL OR \n              activity.actStartTime > state.currentBlock.end\n         THEN {\n           currentBlock: {\n             duration: activity.actDurationInMinutes,\n             start: activity.actStartTime,\n             end: activity.actEndTime\n           },\n           longestBlock: \n             CASE\n               WHEN activity.actDurationInMinutes > state.longestBlock.duration\n               THEN {\n                 duration: activity.actDurationInMinutes,\n                 start: activity.actStartTime,\n                 end: activity.actEndTime\n               }\n               ELSE state.longestBlock\n             END\n         }\n         ELSE {\n           currentBlock: {\n             duration: (activity.actEndTime.hour * 60 + activity.actEndTime.minute) - \n                       (state.currentBlock.start.hour * 60 + state.currentBlock.start.minute),\n             start: state.currentBlock.start,\n             end: activity.actEndTime\n           },\n           longestBlock: \n             CASE\n               WHEN ((activity.actEndTime.hour * 60 + activity.actEndTime.minute) - \n                     (state.currentBlock.start.hour * 60 + state.currentBlock.start.minute)) > state.longestBlock.duration\n               THEN {\n                 duration: (activity.actEndTime.hour * 60 + activity.actEndTime.minute) - \n                           (state.currentBlock.start.hour * 60 + state.currentBlock.start.minute),\n                 start: state.currentBlock.start,\n                 end: activity.actEndTime\n               }\n               ELSE state.longestBlock\n             END\n         }\n       END\n   ) AS finalState\nRETURN\ns.stuFullName_anon AS student,\nactivities[0].actStartDate AS date,\nfinalState.longestBlock.duration AS longestConsecutiveBlockDuration,\nfinalState.longestBlock.start AS blockStartTime,\nfinalState.longestBlock.end AS blockEndTime\n\"\"\"\n\nprint(\"Running query...\\n\")\nresult = session.run(query)\n\n#  list to hold records\nrecords = []\nfor record in result:\n  records.append(record)\n\n# df\ndf = pd.DataFrame(records, columns=[\"student\", \"date\", \"longestConsecutiveBlockDuration\", \"blockStartTime\", \"blockEndTime\"])\n\n# print \nprint(df.head(5))\n\n# close session and driver\nsession.close()\ndriver.close()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nConnecting to Neo4j database....\nConnected to Neo4j database successfully! Driver: <neo4j._sync.driver.Neo4jDriver object at 0x00000244F5FF3450>\nRunning query...\n\n       student        date  longestConsecutiveBlockDuration  \\\n0  Susan Lopez  2022-09-27                              300   \n\n       blockStartTime        blockEndTime  \n0  13:00:00.000000000  18:00:00.000000000  \n```\n:::\n:::\n\n\n### Max hours in a day\n\nThis query calculates the total hours spent on activities for each student on each day and returns the results ordered by date. This examples filters for students who have more than 7 hours of activities in a day.\n\n```cypher\n// sum of activity durations\n// does not account for simultaneous activities (clashes) - so could be inflated, e.g. 12.5 hour students\n\nMATCH (s:student)-[:ATTENDS]->(a:activity)\nWITH s, a.actStartDate AS Date, SUM(a.actDurationInMinutes) / 60.0 AS totalHours\nWHERE totalHours > 7 // Set  maximum here\nRETURN s.stuFullName_anon AS Student, Date, totalHours\nORDER BY Date;\n```\n\n![Max hours in a day](./images/cypher-maxTotalDay.png)\n\n### Lunch breaks\n\n``` cypher\n\nMATCH (s:student)-[:ATTENDS]->(a:activity)\nWITH s, a\nORDER BY a.actStartDate, a.actStartTime\nWITH s, COLLECT(a) AS activities\nUNWIND activities AS activity\nWITH s.stuFullName_anon AS Student, activity.actStartDate AS Date, time(activity.actStartTime) AS StartTime, time(activity.actEndTime) AS EndTime, duration.between(time('12:00'), time('14:00')).minutes AS BreakWindow_12_14\nWITH Student, Date, BreakWindow_12_14, COLLECT([StartTime, EndTime]) AS Activities\nUNWIND Activities AS activity\nWITH Student, Date, BreakWindow_12_14, activity[0] AS StartTime, activity[1] AS EndTime\nWITH Student, Date, BreakWindow_12_14,\n     CASE\n       WHEN StartTime >= time('14:00') OR EndTime <= time('12:00') THEN 0\n       WHEN StartTime < time('12:00') AND EndTime > time('14:00') THEN BreakWindow_12_14\n       WHEN StartTime >= time('12:00') AND StartTime < time('14:00') THEN duration.between(StartTime, time('14:00')).minutes\n       WHEN EndTime > time('12:00') AND EndTime <= time('14:00') THEN duration.between(time('12:00'), EndTime).minutes\n     END AS BookedDurationMinutes\nRETURN Student, Date, BreakWindow_12_14, BreakWindow_12_14 - SUM(BookedDurationMinutes) AS FreeTimeMinutes, SUM(BookedDurationMinutes) AS BookedTimeMinutes\nORDER BY Date\n```\n\n![Lunch breaks](./images/cypher-lunchBreak.png)\n\nInterestingly, `Michael Johnson` has a negative lunch break. I quick look showed that there are actually two `Michael Johnsons` attending this class and they both have 30 minutes free time in the 2-hour lunch break window.\n\nBecause the query was written using student name, it is incorrectly aggregating the two students into one:\n\n$$\n2 \\text{ hour lunch window} - (1.5 \\text{ hours/class} \\times 2 \\text{ classes}) = -1 \\text{ hour}\n$$\n\n**Learning points and TODO:**\n\n-   Update query to use student ID\n-   Anonymisation function needs to be improved to avoid duplicated names\n\n",
    "supporting": [
      "appendix-cypher6_files"
    ],
    "filters": [],
    "includes": {}
  }
}