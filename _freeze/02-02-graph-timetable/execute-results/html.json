{
  "hash": "c6ba46b1f1a57a10b1ecdafd1241162b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Graph Data Model for Timebling\n---\n\n\n\n\n::: callout-warning\n## TODO\n\n- write up section - review notes\n- new page of difficulties with time - see poc2 time\n- appendix with queries (queries.ipynb (graph-project\\docs\\notes\\queries.ipynb)) - copy all queries onto one appendix see graph-tt\n:::\n\nHaving discussed some advantages of graph databases for representing interconnected data, this section delves into the specifics of a proposed graph data model tailored for university timetabling. This model serves as the foundation for our exploration of graph-based analysis and its potential to unlock valuable insights.\n\n## An Iterative Approach\n\nThe design of this graph data model follows an iterative process: design, build, test, review, and revise. Using Neo4j Desktop and an Aura cloud instance, the model began with a small scope, incorporating minimal nodes and properties. This iterative approach allows for flexibility and refinement based on real-world data and evolving requirements.\n\n## Core Nodes: The Building Blocks\n\nAt its core, the timetable model revolves around four key entities represented as nodes:\n\n\n| Node     | Property    | Description           | Data Type |\n|----------|-------------|-----------------------|-----------|\n| Student  | firstName   | Legal first name      | string    |\n|          | lastName    | Legal last name       | string    |\n|          | studentID   | University identifier | integer   |\n|          | splusID     | Timetable URN         | string    |\n| Lecturer | firstName   | First name            | string    |\n|          | lastName    | Last name             | string    |\n|          | staffID     | University identifier | integer   |\n|          | splusID     | Timetable URN         | string    |\n| Room     | name        | Room name             | string    |\n|          | splusID     | Timetable URN         | integer   |\n| Activity | name        | Activity name         | string    |\n|          | description | Activity description  | string    |\n|          | startTime   | Scheduled start time  | datetime  |\n|          | endTime     | Scheduled end time    | datetime  |\n|          | date        | Date of activity      | date      |\n\n![Neo4j Interface showing basic nodes nad properties](./images/poc1-import-interface.png)\n\n## Defining Relationships: Connecting the Dots\n\nThese core nodes are interconnected through relationships that reflect the dynamics of a timetable:\n\n* **Student-[IS_ALLOCATED_TO]->Activity**: Represents a student's allocation to a specific activity.\n* **Staff-[TEACHES_ON]->Activity**:  Indicates the staff member responsible for teaching an activity. \n* **Activity-[TAKES_PLACE_IN]->Room**:  Connects an activity to the room where it is scheduled.\n\n\n![Core Nodes and Properties](./images/v1-core-nodes-rels-prop.png)\n\n\n\n## Early Insights: Unveiling Basic Patterns\n\nEven with this basic model, we can easily extract valuable insights:\n\n* **Activity Load**: Identify staff with the highest number of teaching activities or total teaching hours.\n* **Student Timetable Profiles**: Calculate average hours per student or per programme to understand workload distribution.  \n* **Resource utilisation**: Determine the busiest locations or times on campus based on activity scheduling.\n* **Anomaly detection**: Identify students who have unexpected profiles or unusual combinations\n\n### Examples\n\n#### Busiest location overall\n\n\n\n```{cypher}\nMATCH (r:Room)<-[:TAKES_PLACE_IN]-(a:Activity)\nWITH r, sum(a.duration) AS totalDuration\nRETURN r.name AS Room, totalDuration\nORDER BY totalDuration DESC\nLIMIT 1\n```\n\n\n\n#### Busiest location for a specific time\n\n\n\n\n```{cypher}\nMATCH (r:Room)<-[:TAKES_PLACE_IN]-(a:Activity)\nWHERE a.startTime = \"1100\" \nWITH r, count(a) AS activityCount\nRETURN r.name AS Room, activityCount\nORDER BY activityCount DESC\nLIMIT 1 \n```\n\n\n\n\n#### Students with below/above average hours \n\n\n\n```{cypher}\n// Calculate program averages and standard deviations\nMATCH (s:Student)-[:IS_ALLOCATED_TO]->(a:Activity)\nWITH s.prog AS program, AVG(a.duration) AS avgDuration, STDEV(a.duration) AS stdDev\nGROUP BY program\n\n// Identify students outside the 10% margin \nMATCH (s:Student)-[:IS_ALLOCATED_TO]->(a:Activity)\nWITH s.studentID AS studentID, s.prog AS program, SUM(a.duration) AS totalDuration\nMATCH (avgData)\nWHERE avgData.program = program\nWITH studentID, program, totalDuration, avgData.avgDuration AS avgDuration, avgData.stdDev AS stdDev\nWHERE totalDuration < avgDuration - (0.1 * avgDuration) OR totalDuration > avgDuration + (0.1 * avgDuration)\nRETURN studentID, program, totalDuration, avgDuration, stdDev \nORDER BY program, totalDuration DESC\n```\n\n\n\n\n\n## Expanding the Model: Towards Richer Insights\nThe true power of the graph model lies in its extensibility. Introducing additional nodes and properties allows for a more comprehensive representation and enables more sophisticated analysis.\n\n### Potential Expansions:\n* Organizational Units: Include departments, colleges, or schools to analyze timetabling within organizational structures.\n* Curriculum Data: Incorporate modules and programs to understand the interconnectedness of courses and student enrollment patterns.\n* Activity Types: Differentiate between lectures, seminars, labs, etc., for a more granular analysis of teaching and learning activities.\n* Student Attributes: Add properties like \"international student\" or \"first-year student\" to explore potential disparities in timetabling.\n\n[Image Suggestion: Use your \"v2.0-expanded-tt.png\" to visualize the expanded graph model and its potential for deeper insights.]\n\n## The Challenge of Time: Finding the Optimal Representation\n\nModeling time within a graph database presents a unique challenge. While your initial approach of representing time as properties on the Activity node works for basic analysis, it limits the ability to answer more nuanced questions related to time patterns and potential scheduling conflicts.\n\nYour exploration of alternative approaches highlights the flexibility of graph databases but also the need for careful consideration based on the desired analytical outcomes. Future work exploring dynamic node creation for start times, end times, and dates with direct performance comparisons against specific use cases will be valuable.\n\nThis section has established the foundation for a graph-based approach to university timetabling. The next section will delve into the data engineering pipeline required to populate and maintain this model, bridging the gap between raw data and insightful analysis.\n\n\n\n\n\n# approach\n\niterative: design, build, test, review, revise and back to design\nUsed: neo4j desktop and cloud instance\nstarted small (data wise -> me and complexity (minimal nodes, minimal properties)\nthings went wrong - many examples of wrong nodes, multiple relationships or more frustratingly - failure and error codes\n\n\n# nodes\n\nThe key nodes (nouns) in a timetable are: \n\n* Student (Person)\n* Staff (Person)\n* Activity (Event)\n* Room (Location) \n\nThe key nodes (nouns) are:\n\n| Node     | Property    | Description           | Data Type |\n|----------|-------------|-----------------------|-----------|\n| Student  | firstName   | Legal first name      | string    |\n|          | lastName    | Legal last name       | string    |\n|          | studentID   | University identifier | integer   |\n|          | splusID     | Timetable URN         | string    |\n| Lecturer | firstName   | First name            | string    |\n|          | lastName    | Last name             | string    |\n|          | staffID     | University identifier | integer   |\n|          | splusID     | Timetable URN         | string    |\n| Room     | name        | Room name             | string    |\n|          | splusID     | Timetable URN         | integer   |\n| Activity | name        | Activity name         | string    |\n|          | description | Activity description  | string    |\n|          | startTime   | Scheduled start time  | datetime  |\n|          | endTime     | Scheduled end time    | datetime  |\n|          | date        | Date of activity      | date      |\n\n* sample cypher of loading self (v1-core-load-student-node.png)\n* results v1-core-load-all-nodes.png\n\n\n* example of a student node (me) ![student detail](../images/v1.1-core-student-phl.png)\n* all nodes loaded for MSc Data Science 2022-23 students: \n  * ![all-nodes-for-posi](../images/v1.1-load-all-nodes.png)\n  * no relationships\n# relationships\n\nThe nodes are related as follows: \n\n* `Student` *allocated to* `Activity`\n    * alternatives include *attends*\n* `Staff` *teaches on* `Activity`\n    * alternatives include *lectures*, *leads*, etc.\n* `Activity` *takes place in* `Room`\n    * alternatives include *scheduled in*\n\nIt is clear that `Activity` is the central node in the basic model.\n\n![core nodes with relationships](attachment:v1-core-nodes-rels.png)\n\n* loaded into neo4j ![v1.1 full model](../images/v1.1-core-full-model.png)\n  * two clusters?  waht are they\n  * some orphans?  who/waht are they?\n\n* basic query examples - probably not worth \n  * staff with most activities, hours\n  * average hours per student, per programme\n  * most popular activities\n  * most popular tutors (attendance)\n  * days with most activities\n  * times with most activities / scheduled hours/start times\n  * histogram of activities by day\n  * most popular combinations (modules, pairs of modules, triplets)\n    * most attended \n  * most attendance percentage\n  * relationship between attendance and time/day of activity\n  * anomalies, combinations\n\n# properties\n\n* dependent on use cases - which questions are to be answered\n* some may be better as nodes, others as properties on node or properties on relationship\n* no right or wrong - highly experimental, needs to be tested, optimised\n* flexbility of graph to accommodate\n\n* each node person/student, person/staff, activity, room needs some properties\n  * name, id, description\n  * activity needs date, times, (although modelling time has many varieties)\n\nimage of final proof of concept simple model: v1-core-nodes-rels-prop.png\n\n\n# expansions\n\nmore nodes from timetable db could include:\n\n* organisational unit (department, college, school)\n* curriculum data (module, programme) - activity is part of module, programme made of modules (compulsory, optional)\n* students who are pal leaders (as a mentoring relationship)\n* activity type (property or node) - lecture, seminar, workshop, lab\n* delivery type (property or node) - online, on-campus, recorded, optional, drop-in\n* technician staff facilitating workshops\n* equipment requirements in rooms\n\n\n\nmore student properties could include:\n* reasonable adjustments\n* international student\n* first year student\n* pal leader\n\nexample of expanded model: ![Title](../images/v2.0-expanded-tt.png)\n\nthis would allow for quickly getting insights such as: \n\n* Identify students with anomalous timetables - e.g. timetables that have gaps of more than 2 hours between activities, or that violate a policy of no more than X hours per day. \n* Find the **busiest locations** on campus - analyse room nodes to identify those with the most connected activity nodes on a given day. Useful for improving room bookings.\n* Identify **outlier teaching loads** - find staff with significantly more or fewer allocated teaching hours compared to their peers. Analyse each staff node's connected activity nodes and sum the durations\n* Analyse **room utilisation** - calculate the percentage of available hours that rooms are booked based on their connected activities. Help optimise room usage.\n* Identify **module co-dependencies** - find modules that are often taken together by analysing frequent appearing :CONTRIBUTES_TOWARDS relationships between modules taken by the same students.\n* **Cluster students** based on their curriculum/programs using community detection algorithms on the connections between student nodes, program nodes and module nodes. Identify common trajectories.\n* **Predict student results** - build a model based on relationships between student attributes, their enrollment relationships to modules, module difficulties and prerequisites, and historical grade data\n* Make **course recommendations** - suggest new modules to students based on their existing modules and other similar students' module relationships.\n\nthen the possible:\n\n* adding more location data - buildings, latitude, longitude\n* student details - home postcode (travel distance), \n* student outcomes - module marks, award outcomes, graduate outcomes\n* admissions data - (free lunch scheme, social economic data, a-level results, inclusivity insights)\n* curriculum data - from master curriculum data\n* engagement data - attendance, engagement\n* space use data - wifi locators, how busy areas are, correlations\n* \n\n\n## time\n\nmodelling time in graph was challenging.  my simple model above does take time into account other than to have startTime, endTime, date.  In reality, an activity can take have the same start time, end time but be scheduled over several weeks - sometimes consecutive, sometimes non-consecutive weeks.  How should this be represented?  week patterns?  date ranges?  or separate activities?  what happens when an activity is scheduled over several days but the same time over several weeks for example, Mondays and Wednesdays between 09:00-11:00 for ten weeks?\n\nthis is where normalisation (footnote) and different designs come into play.  In a relational database, it is fairly easy to normalise the data into activities where start and end time and day(s) of week, staff, locations, students are the same for the week pattern.  Any deviation will require a new 'activity' to accommodate the difference.  Therefore there is an inevitable repetition of data.\n\nIn graph these scenarios can be handled in different ways.  My initial model simply ported data as string data to an activity - that is, I literally created an activity as it existed in database and added start time, end time, weeks, etc. as properties of the activity.  \n\nThis worked to an extent but it was not optimised for calculating on time.  \n\nI anticipated being able to answer questions and identify patterns like:\n\n* students on programmes who do not have a lunch break (12:00-14:00)\n* students who have X hours consecutive teaching without a break\n* students who have X hours between teaching activities on any given date (e.g. early activity (09:00-10:00) and late finish (18:00-19:00))\n\nBeing able to answer these types of queries easily will help pinpoint where there may be timetable quality concerns.\n\nI considered and explored differnet options including:\n\n1. activities with 52 week patterns (0000011101 etc.), start and end times\n2. activities which are unique combinations of date, start, end, name\n3. activities with date ranges, start and end times\n4. activities linked to start time, end time and date nodes\n\nAt this point, I did remember the project's scope and reminded myself that it is a proof of concept.  I settled for option 2 - where each activity is a unique combination of start, end, date and name.  This required transforming from sql - there is some loss of redundancy but calculations on times are more manageable (although not uncomplicated).  Also being restricted by Neo4j's free aura instance, there is a limit to nodes (200K) and relationships (400K) which I would hit quickly.\n\nMy suspicion is that creating separate nodes for start and end times and dates dynamically from the activity data would be the better model - but this will need to be future work with direct comparisons aganst specific use cases and insights. \n\n\n## appendix - \n\n### example load\n\n#### Attempt 2 - load separately\n\n```cypher\n// remove all relationships\nMATCH ()-[r]-() \nDELETE r\n```\n\n\n**activity-room**\n\n```cypher\n// Activity-Room\nLOAD CSV WITH HEADERS FROM \"file:///phl-rel-room-activity.csv\" AS row3\nMATCH (r:Room {roomSplusID: row3.roomSplusID}) \nMATCH (a:Activity {activitySplusID: row3.activitySplusID})\nCREATE (a)-[:TAKES_PLACE_IN]->(r)\n```\n**activity-staff**\n\n```cypher\n// Staff-activity \nLOAD CSV WITH HEADERS FROM \"file:///phl-rel-staff-activity.csv\" AS row2\nMATCH (s:Staff {staffSplusID: row2.staffSplusID}) \nMATCH (a:Activity {activitySplusID: row2.activitySplusID})\nCREATE (s)-[:TEACHES_ON]->(a)\n```\n\n**activity-student**\n\n```cypher\n// Student-Activity\nLOAD CSV WITH HEADERS FROM \"file:///phl-rel-student-activity.csv\" AS row\nMATCH (s:Student {studentSplusID: row.studentSplusID}) \nMATCH (a:Activity {activitySplusID: row.activitySplusID})\nCREATE (s)-[:IS_ALLOCATED_TO]->(a)\n```\n\n# results\n\nv1-core-poc.png\n\n",
    "supporting": [
      "02-02-graph-timetable_files"
    ],
    "filters": [],
    "includes": {}
  }
}