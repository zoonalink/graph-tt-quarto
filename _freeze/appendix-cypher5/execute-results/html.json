{
  "hash": "4dbc892d105589dd2c1778ad79cac4db",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Hard Constraints\"\nlightbox:\n  match: auto\n  effect: fade\n  desc-position: bottom\n  loop: false\n---\n\n\n\n<br>\n\n\"Hard constraints\" in a timetabling context are generally rules or conditions which cannot be violated.  Violation would indicate non-viable timetable, e.g. a lecturer being scheduled to teach in two places simultaneously.  In reality, hard constraints appear in timetables and are accepted with real-world workarounds.\n\nThis page contains cypher queries that can be used to identify where a timetabling hard constraint has been violated.\n\nExample hard constraints include:\n\n* **All Activities Scheduled**: Every lecture, tutorial, lab, etc., must have a designated time and place.\n* **No Room Conflicts (aka room clash)**: Two activities cannot be scheduled in the same room at the same time.\n* **Room Capacity Sufficient**: The room assigned to an activity must accommodate the expected number of students\n* **Person clashes**: People, that is staff and students, cannot be allocated to two or more activities occurring at the same time.\n  * **No Staff Conflicts (aka staff clash)**\n  * **No Student Conflicts (aka student clash)**\n* **Staff Availability Respected**: Activities cannot be scheduled during a staff member's unavailable times (e.g., research days, meetings, unavailability pattern).\n* **Curriculum Requirements Met**: Required courses must be offered at times when students can take them\n\n\n### Unscheduled activities\n\nUnscheduled activities can be identified as follows. This query can be tweaked to also search for matches where the property equals '' - that is, a blank.\n\n```cypher\nMATCH (a:activity)\nWHERE a.actStartDate IS NULL \nOR a.actStartTime IS NULL \nOR a.actEndTime IS NULL\nRETURN a\n```\n\n### Room clashes\n\nRoom or location clashes are where two or more activities are scheduled at the same datetime in the same space and this is not deliberate. These can be identified with the starter query below. The image clearly shows pairs of activities sharing one location.  In reality, I suspect that these are deliberate clashes. \n\n```cypher\nMATCH (a1:activity)-[r1:OCCUPIES]->(r:room)<-[r2:OCCUPIES]-(a2:activity)\nWHERE a1.actStartDate = a2.actStartDate AND a1 <> a2\n    AND (\n        (a1.actStartTime <= a2.actStartTime AND a1.actEndTime > a2.actStartTime)\n        OR \n        (a2.actStartTime <= a1.actStartTime AND a2.actEndTime > a1.actStartTime)\n    )\nRETURN a1, a2, r, r1, r2\n```\n![Room Clashes](./images/cypher-room-clash.png)\n\n\nThe same results have been returned as a table.\n\n::: {#b81fd792 .cell execution_count=1}\n``` {.python .cell-code}\nfrom connect_to_neo4j_db import connect_to_neo4j\nfrom neo4j import GraphDatabase\nimport pandas as pd\n\n# connect to Neo4j\ndriver = connect_to_neo4j()\n\n# session\nsession = driver.session()\n\n# run query\nquery = \"\"\"\nMATCH (a1:activity)-[r1:OCCUPIES]->(r:room)<-[r2:OCCUPIES]-(a2:activity)\nWHERE r.roomName IN [\"4Q50/51 FR\", \"4Q69 FR\", \"3E Maths Open Zone A\", \"3E12 FR\"] \n  AND a1.actStartDate = a2.actStartDate \n  AND a1 <> a2\n  AND (\n        (a1.actStartTime <= a2.actStartTime AND a1.actEndTime > a2.actStartTime)\n        OR \n        (a2.actStartTime <= a1.actStartTime AND a2.actEndTime > a1.actStartTime)\n      )\nRETURN a1.actName AS activity1, a2.actName AS activity2, \n       r.roomName AS room, a1.actStartDate AS date,\n       a1.actStartTime AS activity1_start, a1.actEndTime AS activity1_end,\n       a2.actStartTime AS activity2_start, a2.actEndTime AS activity2_end\n\"\"\" \n\nprint(\"Running query...\\n\")\nresult = session.run(query)\n\n# list to hold records\nrecords = []\nfor record in result:\n    records.append(record)\n\n# df\ndf = pd.DataFrame(records, columns=[\"activity1\", \"activity2\", \"room\", \"date\", \n                                   \"activity1_start\", \"activity1_end\", \n                                   \"activity2_start\", \"activity2_end\"])\n\n# print\nprint(df)\n\n# close session and driver\nsession.close()\ndriver.close()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nConnecting to Neo4j database....\nConnected to Neo4j database successfully! Driver: <neo4j._sync.driver.Neo4jDriver object at 0x000001D74F457B90>\nRunning query...\n\n                          activity1                         activity2  \\\n0          UFCF8P-15-M Sep W2_oc/01  UFCF8P-15-M Jan Cont W2_oc jt/01   \n1  UFCF8P-15-M Jan Cont W2_oc jt/01          UFCF8P-15-M Sep W2_oc/01   \n2          UFCF8P-15-M Sep W1_oc/01  UFCF8P-15-M Jan Cont W1_oc jt/01   \n3  UFCF8P-15-M Jan Cont W1_oc jt/01          UFCF8P-15-M Sep W1_oc/01   \n4                     Maths_E_oc/01                    Maths_E5_oc/01   \n5                    Maths_E5_oc/01                     Maths_E_oc/01   \n6                     Maths_E_oc/01              UFMFVV-30-3 DI_oc/01   \n7              UFMFVV-30-3 DI_oc/01                     Maths_E_oc/01   \n\n                   room        date     activity1_start       activity1_end  \\\n0            4Q50/51 FR  2022-12-13  16:00:00.000000000  17:30:00.000000000   \n1            4Q50/51 FR  2022-12-13  16:00:00.000000000  17:30:00.000000000   \n2               4Q69 FR  2022-12-13  14:00:00.000000000  15:30:00.000000000   \n3               4Q69 FR  2022-12-13  14:00:00.000000000  15:30:00.000000000   \n4  3E Maths Open Zone A  2022-11-09  09:00:00.000000000  17:00:00.000000000   \n5  3E Maths Open Zone A  2022-11-09  16:00:00.000000000  17:00:00.000000000   \n6               3E12 FR  2022-11-08  09:00:00.000000000  17:00:00.000000000   \n7               3E12 FR  2022-11-08  15:00:00.000000000  16:00:00.000000000   \n\n      activity2_start       activity2_end  \n0  16:00:00.000000000  17:30:00.000000000  \n1  16:00:00.000000000  17:30:00.000000000  \n2  14:00:00.000000000  15:30:00.000000000  \n3  14:00:00.000000000  15:30:00.000000000  \n4  16:00:00.000000000  17:00:00.000000000  \n5  09:00:00.000000000  17:00:00.000000000  \n6  15:00:00.000000000  16:00:00.000000000  \n7  09:00:00.000000000  17:00:00.000000000  \n```\n:::\n:::\n\n\n### Room capacity exceeded\n\nThis query identifies activities where the number of students exceeds the room capacity. It includes an optional `WHERE` clause if looking at a specific date range.\n\n```cypher\nMATCH (r:room)<-[r1:OCCUPIES]-(a:activity)<-[:ATTENDS]-(s:student)\n//WHERE a.Date >= date(\"2022-01-01\") AND a.Date <= date(\"2022-06-30\") \nWITH r, a, count(s) as numStudents\nWHERE numStudents > r.roomCapacity\nRETURN r, a.actStartDate, a.actName AS Activity, r.roomCapacity, numStudents - r.roomCapacity AS extraNeeded\nORDER BY extraNeeded DESC\n```\n\nThese are the results in a dataframe: \n\n::: {#1dd90a26 .cell execution_count=2}\n``` {.python .cell-code}\nfrom connect_to_neo4j_db import connect_to_neo4j\nfrom neo4j import GraphDatabase\nimport pandas as pd\n\n# connect to Neo4j\ndriver = connect_to_neo4j()\n\n# session\nsession = driver.session()\n\n# run query\nquery = \"\"\"\nMATCH (r:room)<-[r1:OCCUPIES]-(a:activity)<-[:ATTENDS]-(s:student)\n//WHERE a.Date >= date(\"2022-01-01\") AND a.Date <= date(\"2022-06-30\") \nWITH r, a, count(s) as numStudents\nWHERE numStudents > r.roomCapacity\nRETURN DISTINCT r.roomName, r.roomType,  a.actName AS Activity, \n       r.roomCapacity, numStudents - r.roomCapacity AS extraNeeded\nORDER BY extraNeeded DESC\n\"\"\" \n\nprint(\"Running query...\\n\")\nresult = session.run(query)\n\n# list to hold records\nrecords = []\nfor record in result:\n    records.append(record)\n\n# df\ndf = pd.DataFrame(records, columns=[\"roomName\", \"roomType\", \"Activity\", \n                                   \"roomCapacity\", \"extraNeeded\"])\n\n# print\nprint(\"Printing first 5 records...\\n\")\nprint(df.head())\n\n# close the session and driver\nsession.close()\ndriver.close()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nConnecting to Neo4j database....\nConnected to Neo4j database successfully! Driver: <neo4j._sync.driver.Neo4jDriver object at 0x000001D750FF12D0>\nRunning query...\n\nPrinting first 5 records...\n\n               roomName  roomType       Activity  roomCapacity  extraNeeded\n0              3E006 FR  FAC STUD  Maths_E_oc/01             4           88\n1              3E007 FR  FAC STUD  Maths_E_oc/01             4           88\n2  3E Maths Open Zone B  FAC STUD  Maths_E_oc/01            12           80\n3               3E28 FR  TEACHING  Maths_E_oc/01            24           68\n4               3E12 FR    PC LAB  Maths_E_oc/01            30           62\n```\n:::\n:::\n\n\n### Student clashes\n\nThis query identifies students who are scheduled to attend two or more activities at the same time.  Identifying clashes is a complex undertaking and it is one where the graph structure in terms of nodes, properties and relationships could potentially make a significant different to performance. \n\nThe reason for the complexity is that you need to look for overlapping times between two activities for each date, for each student.  The query to achieve this and the ensuing calculations will vary significantly depending on on the structure and syntax. \n\nBecause of this, I explored the student clash scenario in more detail here: [Student Clashes](appendix-cypher5a.qmd)\n\n```cypher\nMATCH (s:student)-[:ATTENDS]->(a1:activity)\nWITH s, a1\nMATCH (s)-[:ATTENDS]->(a2:activity) \nWHERE a1 <> a2 \n  AND a1.actStartDate = a2.actStartDate \n  AND (a1.actStartTime < a2.actEndTime AND a1.actEndTime > a2.actStartTime)  \n  AND NOT (a1.actStartTime = a2.actEndTime OR a1.actEndTime = a2.actStartTime) \n  AND a1.actName < a2.actName  // Ensure only one direction of the pair is returned\nRETURN s.stuFirstName_anon AS Student, \n       a1.actStartDate AS ClashDate, \n       a1.actName AS Activity1, \n       a1.actStartTime + \"-\" + a1.actEndTime AS Timeslot1, \n       a2.actName AS Activity2, \n       a2.actStartTime + \"-\" + a2.actEndTime AS Timeslot2\nORDER BY Student, ClashDate;\n```\n\n![Student Clashes](./images/cypher-student-clash.png)\n\n",
    "supporting": [
      "appendix-cypher5_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}