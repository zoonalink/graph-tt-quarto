{
  "hash": "eb547a164e2bab0a29bbcb865bd68fd7",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Graphing Time\n---\n\n\n\n\nThe biggest challenge I encountered when translating timetables into graph data structures involved temporal elements - that is, start and end times, dates, weeks, recurrences, durations, etc. Whether a data element is a node or a property of a node, or perhaps both is relatively trivial to model and test and depends heavily on use cases.\n\nTime, on the other hand, is complicated, especially when you want to write aggregation queries on time elements e.g. total taught hours on campus on a Wednesday at 11:00 for student X across the whole year.\n\nWhile the conceptual flexibility of graphs is appealing, finding the optimal balance between efficient representation, query performance, and data redundancy requires careful consideration. This section details some challenges encountered and the approach taken for the proof-of-concept.\n\n## The Problem of Normalised Time\n\nTraditional relational databases often store timetable information in a highly normalised[^1] format, condensing recurring events into single rows with date ranges, week patterns, or lists of occurrences. While efficient for storage and basic display, this approach severely hinders analysis, especially when aiming to:\n\n[^1]: \"Normalization is the process of organizing data in a database. It includes creating tables and establishing relationships between those tables according to rules designed both to protect the data and to make the database more flexible by eliminating redundancy and inconsistent dependency.\" (helenclu, 2024)\n\n-   **Identify Time-Based Patterns**: Determining if students lack lunch breaks or experience excessive gaps between classes becomes difficult when time is fragmented across multiple fields.\n-   **Perform Aggregations**: Calculating total teaching hours for a lecturer across specific weeks or days requires complex queries and data transformations.\n-   **Model Temporal Relationships**: Representing relationships between activities based on their temporal proximity, such as students attending consecutive classes, becomes convoluted.\n\n## Exploring Potential Solutions\n\nSeveral time modelling approaches were explored to explore these challenges, each with its own trade-offs.\n\nTo illustrate this, let's explore using a fictional example - `Introduction to Graph Databases` - focusing on the `lecture`:\n\n| Name | ActivityType | Day       | StartTime | EndTime | Weeks          |\n|------|--------------|-----------|-----------|---------|----------------|\n| ITGD | Lecture      | Wednesday | 09:00     | 11:00   | 1-3, 5-7, 9-13 |\n| ITGD | Seminar      | Wednesday | 10:00     | 13:00   | 4, 7-8, 15     |\n| ITGD | Seminar      | Monday    | 13:00     | 16:00   | 4, 7-8, 15     |\n\n: Example Source Data (Relational)\n\n### Option 0: Proof-of-concept activity\n\nThe basic model creates nodes for each activity as they exist in the relational database. This simple approach is perfectly acceptable but makes any time based calculations difficult because each activity node can represent a different number of occurrences because of the week ranges.\n\nThis in turn means you cannot simply COUNT each activity \"equally\" - for example, row one above has 11 instances, each of two hours. The second and third rows have four instances, each of three hours. Calculating aggregations, finding clashes and similar is very challenging.\n\n![Basic example of Graphing Normalised Activities](./images/time-option0.png)\n\nIf we assume that all students attend the lecture and one of the seminars, some students have a clash in week 7 (Wednesday 10:00-11:00) - this is very difficult to identify and isolate in a highly normalised dataset.\n\n### Option 1: Unique Activity Nodes\n\nOption 1 addresses this by creating nodes for each unique combination of `name`, `startTime`, `endTime` and `date` - this means de-normalising the relational data and deliberately introducing duplication.\n\n![Unique Activity Nodes Graph](./images/time-option1.png)\n\n**Graph Structure**:\n\n-   11 separate `Activity` nodes one for each occurrence (date)\n-   Each node has `date`, `startTime`, `endTime` properties\n-   Only `date` is different between each node.\n\n\n\n\n```{cypher .cypher-scroll}       \n(Activity {Name: \"ITGD\", Date: \"2024-01-03\", StartTime: \"09:00\", EndTime: \"11:00\"}) \n(Activity {Name: \"ITGD\", Date: \"2024-01-10\", StartTime: \"09:00\", EndTime: \"11:00\"}) \n... \n(Activity {Name: \"ITGD\", Date: \"2024-03-20\", StartTime: \"09:00\", EndTime: \"11:00\"})\n```\n\n\n\n\n**Pros**:\n\n-   **Conceptual Simplicity**: Easy to understand and implement.\n-   **Direct Time Representation**: Time is directly associated with each activity instance.\n\n**Cons**:\n\n-   **Node Proliferation**: Leads to a high volume of nodes, potentially impacting performance with large datasets.\n\n**Use Case dependent**\n\n-   **Time-Based Queries**: Answering questions about time patterns or conflicts requires traversing numerous nodes and relationships. Some queries will benefit - e.g. identifying clashes which may only occur in a specific week, others will become more complex as de-normalised data needs to be re-aggregated.\n\n### Option 2: Date and Time Nodes\n\nOption 2 creates a *single activity* node but also additional `date` and `time` nodes, as required, thus not proliferating activities.\n\n![Time and Date Nodes](./images/time-option2.png)\n\n**Graph Structure**:\n\n-   1 Activity node\n-   11 Date nodes - shared by ALL activities on those dates.\n-   2 Time nodes (09:00 and 11:00) - shared by ALL activities on those times!\n-   **Additional Relationships**\n    -   Activity -[:SCHEDULED_ON]-> Date (11 relationships)\n    -   Activity -[:STARTS_AT]-> Time (11 relationships to 09:00)\n    -   Activity -[:ENDS_AT]-> Time (11 relationships to 11:00)\n\n<br>\n\n\n\n\n```{cypher .cypher-scroll}         \n(Activity {Name: \"ITGD\"})\n    -[:SCHEDULED_ON]-> (Date {date: \"2024-01-03\"})\n    -[:SCHEDULED_ON]-> (Date {date: \"2024-01-10\"})\n    ...\n    -[:STARTS_AT]-> (Time {time: \"09:00\"}) \n    -[:ENDS_AT]-> (Time {time: \"11:00\"})\n```\n\n\n\n\n**Key point**: Relationships encode which activity happens when.\n\n**Pros**:\n\n-   **Increased Flexibility**: Facilitates queries across time ranges and aggregations across time slots.\n-   **Reduced Redundancy**: Avoids replicating time information for activities occurring on the same date and time.\n-   **Lower Node Count**: Potentially fewer nodes overall compared to Option 1 as `date` and `time` nodes are shared with all activities in the database.\n\n**Cons**:\n\n-   **Increased Model Complexity**: Requires managing relationships between Activity, Date, and Time nodes.\n-   **Potential Performance Overhead**: Querying might involve traversing multiple relationships, impacting efficiency.\n\n### Option 3: Date and Time Block Nodes\n\nOption 3 creates a single activity but instead of individual start and end time nodes, we use predetermined `timeBlocks` encompassing both. For example, if using 30-minute blocks, we would have a node for \"09:00-09:30\" and another for \"09:30-10:00\", etc.\n\n![TimeBlock and Date Nodes](./images/time-option3.png)\n\n**Graph Structure**:\n\n-   1 Activity node\n-   11 Date nodes\n-   4 Timeblock nodes (09:00-09:30, etc.) - shared by ALL activities on those times!\n-   **Additional Relationships**\n    -   `Activity` -[:SCHEDULED_ON]-> `Date` (11 relationships)\n    -   `Activity` -[:TAKES_PLACE_DURING]-> `timeBlock 09:00-09:30` (11 relationships)\n    -   `Activity` -[:TAKES_PLACE_DURING]-> `timeBlock 09:30-10:00` (11 relationships) \n    -   ...\n  \n\n\n\n```{cypher .cypher-scroll}\n(Activity {Name: \"ITGD\"}) \n    -[:SCHEDULED_ON]-> (Date {date: \"2024-01-03\"}) \n    -[:SCHEDULED_ON]-> (Date {date: \"2024-01-10\"})\n    ...\n    -[:TAKES_PLACE_DURING]-> (TimeBlock {timeBlock: \"09:00-09:30\"}) \n    -[:TAKES_PLACE_DURING]-> (TimeBlock {timeBlock: \"09:30-10:00\"})\n    -[:TAKES_PLACE_DURING]-> (Timeblock {timeBlock: \"10:00-10:30\"}) \n    -[:TAKES_PLACE_DURING]-> (Timeblock {timeBlock: \"10:30-11:00\"})\n```         \n\n\n\n\n**Pros**:\n\n-   **Granular Time Representation**: Enables analysis at specific time intervals\n-   **Easier Time Calculations**: Duration is encoded and allows for easy calculations.\n\n**Cons**:\n\n-   **Potential for Data Sparsity**: Some time blocks might be sparsely populated, leading to storage inefficiencies.\n-   **Potential for High Node Codes**: Lots of `TimeBlocks` if using small intervals\n-   **Less flexibile**: Timeblocks are not dynamic.\n\n### Variations\n\n**StartTime and Duration**: This option simplifies the model by representing time using only `StartTime` and `DurationInMinutes` properties on the `Activity` node, omitting explicit `EndTime` nodes. This approach is suitable for duration based queries but it is limiting in that it is more difficult to query events occurring at specific times, overlapping time ranges or on end-times.\n\n**Time Chains**: This option retains date and time nodes, but instead of having relationships from activity, the nodes are chained:  `activity` -> `startTime` -> `endTime`.\n\n**Dynamic TimeBlocks**: This variation does not pre-create timeblocks based on a set interval (e.g. 30 minutes). They are created dynamically as required by the data and what already exists. For example, activities at 09:00-11:00, 10:30-11:30 and 11:00-12:00 would require these TimeBlocks:\n\n\n\n\n```{cypher}\n(Timeblock {name: \"09:00-11:00\", start: 09:00, end: 11:00, duration:120}) (Timeblock {name: \"10:30-11:30\", start: 10:30, end: 11:30, duration:60}) (Timeblock {name: \"11:00-12:00\", start: 11:00, end: 12:00, duration:60})\n```\n\n\n\n\n### Summary\n\n|   | Option | Pros | Cons |\n|--|------------------|---------------------------|---------------------------|\n| 0 | Direct transfer (Normalised) | Simple | Minimal benefits (for time calculations) |\n| 1 | Unique Activities | Simple, direct | High node count, complex time pattern queries |\n| 2 | Date & Time | Lower activity node count, good for time-based queries | More complex relationships |\n| 3 | Date & TimeBlock | Granular, easier duration calculations | Potentially high node count, sparsity if blocks are fine-grained |\n\n: Option summary\n\nGiven the proof-of-concept scope of this project, I chose to proceed with Option 1. While this approach can lead to node proliferation, it offers the most straightforward implementation for exploring fundamental time-based queries and insights. It also acts as an easy jumping off point for exploring any of the other options.[^2]\n\n[^2]: Some of the above variations are explored in [Appendix-Student Clashes](appendix-cypher5a.qmd)\n\n",
    "supporting": [
      "02-03-graph-time_files"
    ],
    "filters": [],
    "includes": {}
  }
}