{
  "hash": "7eed016da6cf5a4604b6e5780a80f53e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Implementing TQI\"\nlightbox:\n  match: auto\n  effect: fade\n  desc-position: bottom\n  loop: false\n---\n\n\n\n\n\n\n\n\n\nPrototype queries have been identified to identify constraint violations.  Several of these queries are quite complex but their final form will dependent on the use-case as well as the graph data model.  \n\nAs a simple example, the following query identifies students with back-to-back activities in different buildings, highlighting a potential travel time issue:\n\n\n\n\n\n\n\n\n\n```{cypher}\n// Identify students with back-to-back activities in different buildings\nMATCH (s:Student)-[:ATTENDS]->(a1:Activity)-[:NEXT]->(a2:Activity)\nWHERE a1.endTime = a2.startTime AND a1.building <> a2.building\nRETURN s.name, a1.name, a2.name, a1.building, a2.building\n```\n\n\n\n\n\n\n\n\n\nOr we could craft a query to calculate the travel time between back-to-back activities:\n\n```{cypher}{.scroll-cypher}\n// Calculate travel time between consecutive activities for a student on a specific date\nMATCH (s:student {stuFullName_anon: \"David Johnson\"})-[:ATTENDS]->(a1:activity)-[:OCCUPIES]->(r1:room),\n      (s)-[:ATTENDS]->(a2:activity)-[:OCCUPIES]->(r2:room)\nWHERE a1.actEndTime = a2.actStartTime AND a1.actStartDate = a2.actStartDate AND a1 <> a2 AND\n      a1.actStartDate IN [date(\"2023-01-11\"), date(\"2022-09-27\"), date(\"2023-03-14\")] \nRETURN DISTINCT \n    s.stuFullName_anon, \n    a1.actName AS act1, a1.actStartDate AS date, a1.actStartTime+\"-\"+a1.actEndTime AS act1Times, a2.actStartTime+\"-\"+a2.actEndTime AS act2Times, a2.actName AS act2,\n    point.distance(r1.location, r2.location) AS distance,\n    round(point.distance(r1.location, r2.location) / 1.4) AS walkingTimeSeconds // Calculate walking time in seconds\n```\n\n![Travel time between activities](./images/cypher-b2b-travel.png)\n\nSee  [Cypher Queries - Hard Constraints](appendix-cypher5.qmd) and [Cypher Queries - Soft Constraints](appendix-cypher6.qmd) for more examples and details.\n\n\n### Penalty and Reward System\n\nOne way of implementing this is to store the quality score as a property on the relevant node (student, programme, room, etc.).  Starting with a baseline score, the quality score is dynamically updated by subtracting penalties and adding rewards based on the specific metrics calculated. The weighting of these penalties and rewards can be adjusted to reflect institutional priorities. \n\nUsing the back-to-back activities example above, we can imagine using either `distance` or `walkingTimeSeconds` and a sliding scale to calculate a penalty.  For example, if the walking time is greater than 5 minutes, a penalty of -3 points could be applied with the penalty increasing as the walking time increases.\n\nFurther examples: \n\n**No lunch break**: -5 points\n\n**Back-to-back activities 5+ minutes apart**: -3 points per instance\n\n**Activity clash**: -10 points\n\n**Room at full capacity**: -2 points\n\n**High room utilisation rate:** +2 points\n\n",
    "supporting": [
      "04-03-timetable-cypher_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}