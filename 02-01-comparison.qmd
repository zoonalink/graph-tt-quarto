---
title: Graph vs Relational Data Models
execute:
  enabled: false
---

::: callout-warning
## TODO

-   find graph, rel quotes
-   add refernces
-   update images and text
-   
:::

## Relational Models: Tables, Joins and the Limits of Interconnectedness

Relational databases, using SQL as their query language, have long been the go-to for managing data, including timetabling information. They structure data into tables, where rows represent entities (like rooms, staff, or students) and columns represent their attributes (name, capacity, email, etc.). Relationships between these entities are established through foreign keys, forming links between tables. This often involves intermediary "relationship" tables to handle the many-to-many nature of timetabling data (e.g., a student attends many activities, and an activity has many students).

While robust and well-understood, relational databases start to show their limitations when dealing with the highly interconnected nature of timetables:

-   **Join Complexity**: Even seemingly simple queries, like "find students attending a specific lecturer's class in a particular building," require joining multiple tables. As queries become more nuanced, the number of joins increases, often impacting performance, especially with large datasets.

-   **Rigidity**: Relational databases rely on a predefined schema, making them less adaptable to evolving needs. Adding new entities or relationships, a common occurrence in dynamic timetabling environments, often requires schema modifications, potentially disrupting existing queries and applications.

```{dot}
graph timetable {
  node [shape=record];

  // Tables as nodes
  ACTIVITY [label="{ACTIVITY | db_id (PK)\l| name \l| start_time\l| end_time\l| duration\l| ...}"];
  STAFF [label="{STAFF | db_id (PK)\l| first_name\l| last_name\l| title\l| email\l| ...}"];
  STUDENT [label="{STUDENT | db_id (PK)\l| first_name\l| last_name\l| email\l| dob\l| ...}"];
  ROOM [label="{ROOM | room_id (PK)\l| name\l| building\l| capacity\l| ...}"];

  // Relationship tables - less emphasis
  STAFF_ACTIVITY [label="STAFF_ACTIVITY\nstaff_db_id (FK)\nactivity_db_id (FK)", fontsize=10];
  ROOM_ACTIVITY [label="ROOM_ACTIVITY\nroom_id (FK)\nactivity_db_id (FK)", fontsize=10];
  STUDENT_ACTIVITY [label="STUDENT_ACTIVITY\nstudent_db_id (FK)\nactivity_db_id (FK)", fontsize=10];

  // Relationships
  ACTIVITY -- STAFF_ACTIVITY;
  STAFF -- STAFF_ACTIVITY;
  ACTIVITY -- ROOM_ACTIVITY;
  ROOM -- ROOM_ACTIVITY;
  ACTIVITY -- STUDENT_ACTIVITY;
  STUDENT -- STUDENT_ACTIVITY;
}

```

![Simple Relational Data Model](./images/SQL-erd.png)

```{sql}
-- Assuming "BuildingName" is in V_BUILDING and linked to V_LOCATION


SELECT DISTINCT 
    ss.[FirstName], 
    ss.[LastName],
    ss.[Email]
FROM [RDB_MAIN2223].[rdowner].[V_STUDENTSET] ss
INNER JOIN [RDB_MAIN2223].[rdowner].[V_ACTIVITY_STUDENTSET] acts ON ss.[Id] = acts.[StudentSetId]
INNER JOIN [RDB_MAIN2223].[rdowner].[V_ACTIVITY] a ON acts.[ActivityId] = a.[Id]
INNER JOIN [RDB_MAIN2223].[rdowner].[V_ACTIVITY_LOCATION] al ON a.[Id] = al.[ActivityId]
INNER JOIN [RDB_MAIN2223].[rdowner].[V_LOCATION] l ON al.[LocationId] = l.[Id]
INNER JOIN [RDB_MAIN2223].[rdowner].[V_BUILDING] b ON l.[BuildingId] = b.[Id] -- Assuming a BuildingId column in V_LOCATION
INNER JOIN [RDB_MAIN2223].[rdowner].[V_ACTIVITY_STAFF] ast ON a.[Id] = ast.[ActivityId]
WHERE ast.[StaffId] = 'StaffID'  
  AND b.[Name] = 'BuildingName'; 
```

## Graph Models: Embracing interconnectedness

In contrast to the rigid table structure of relational databases, graph databases offer a more intuitive and flexible approach for representing interconnected data like timetables. They utilise:

-   **Nodes**: Represent entities (e.g., activity, room, lecturer, student).
-   **Edges**: Represent relationships between nodes (e.g., "taught by," "enrolled in," "scheduled at").

This node-and-edge structure inherently reflects how timetabling elements connect. Instead of relying on cumbersome joins, relationships are directly encoded in the data model itself. This results in several advantages:

-   **Natural Representation**: Graph databases visually and conceptually mirror the relationships inherent in timetables, making them easier to understand and query.
-   **Relationship-Centric Queries**: Graph databases are optimised for traversing and analysing relationships. Queries that would require multiple joins in a relational database often become significantly simpler and faster in a graph database.
-   **Flexibility**: The schema-less or schema-optional nature of most graph databases allows for greater flexibility in data modeling. New entities or relationships can be added effortlessly without impacting existing structures or queries.

![Simple Graph Data Model](./images/v1-core-nodes-rels.png)

```{cypher}
// Assuming properties on nodes
MATCH (s:Student)-[:ATTENDS]->(a:Activity)<-[:TEACHES]-(st:Staff), 
      (a:Activity)-[:TAKES_PLACE_IN]->(r:Room)
WHERE st.last_name = "LecturerLastName" AND r.building = "BuildingName"
RETURN s.first_name, s.last_name, s.email 
```

## Key Differences and Implications

| Feature               | Relational Model                           | Graph Model                                                |
|------------------|------------------------|------------------------------|
| Data Structure        | Tables with rows and columns               | Nodes and edges                                            |
| Schema                | Rigid, predefined                          | Flexible, schema-less or schema-optional                   |
| Relationship Handling | Foreign keys, joins                        | Direct connections (edges)                                 |
| Query Performance     | Can be slow for relationship-heavy queries | Optimised for traversing relationships, potentially faster |
| Data Modeling         | Less intuitive for interconnected data     | Naturally represents complex relationships                 |
| Adaptability          | Less adaptable to schema changes           | More flexible, accommodates evolving data needs            |

These advantages position graph databases as a powerful tool for uncovering insights hidden within complex, interconnected datasets like university timetables. The following section will detail a graph data model specifically designed to leverage these strengths for enhanced timetable analysis.