---
title: "R: Hard Constraints"
lightbox:
  match: auto
  effect: fade
  desc-position: bottom
  loop: false
---
<br>

"Hard constraints" in a timetabling context are generally rules or conditions which cannot be violated.  Violation would indicate non-viable timetable, e.g. a lecturer being scheduled to teach in two places simultaneously.  In reality, hard constraints appear in timetables and are accepted with real-world workarounds.

This page contains cypher queries that can be used to identify where a timetabling hard constraint has been violated.

Example hard constraints include:

* **All Activities Scheduled**: Every lecture, tutorial, lab, etc., must have a designated time and place.
* **No Room Conflicts (aka room clash)**: Two activities cannot be scheduled in the same room at the same time.
* **Room Capacity Sufficient**: The room assigned to an activity must accommodate the expected number of students
* **Person clashes**: People, that is staff and students, cannot be allocated to two or more activities occurring at the same time.
  * **No Staff Conflicts (aka staff clash)**
  * **No Student Conflicts (aka student clash)**
* **Staff Availability Respected**: Activities cannot be scheduled during a staff member's unavailable times (e.g., research days, meetings, unavailability pattern).
* **Curriculum Requirements Met**: Required courses must be offered at times when students can take them


### Unscheduled activities

Unscheduled activities can be identified as follows. This query can be tweaked to also search for matches where the property equals '' - that is, a blank.

```{cypher}{.scroll-cypher}
MATCH (a:activity)
WHERE a.actStartDate IS NULL 
OR a.actStartTime IS NULL 
OR a.actEndTime IS NULL
RETURN a
```

### Room clashes

Room or location clashes are where two or more activities are scheduled at the same datetime in the same space and this is not deliberate. These can be identified with the starter query below. The image clearly shows pairs of activities sharing one location.  In reality, I suspect that these are deliberate clashes. 

```{cypher}{.scroll-cypher}
MATCH (a1:activity)-[r1:OCCUPIES]->(r:room)<-[r2:OCCUPIES]-(a2:activity)
WHERE a1.actStartDate = a2.actStartDate AND a1 <> a2
    AND (
        (a1.actStartTime <= a2.actStartTime AND a1.actEndTime > a2.actStartTime)
        OR 
        (a2.actStartTime <= a1.actStartTime AND a2.actEndTime > a1.actStartTime)
    )
RETURN a1, a2, r, r1, r2
```

![Room Clashes](./images/cypher-room-clash.png)


The same results have been returned as a table.


```{python}
from connect_to_neo4j_db import connect_to_neo4j
from neo4j import GraphDatabase
import pandas as pd

# connect to Neo4j
driver = connect_to_neo4j()

# session
session = driver.session()

# run query
query = """
MATCH (a1:activity)-[r1:OCCUPIES]->(r:room)<-[r2:OCCUPIES]-(a2:activity)
WHERE r.roomName IN ["4Q50/51 FR", "4Q69 FR", "3E Maths Open Zone A", "3E12 FR"] 
  AND a1.actStartDate = a2.actStartDate 
  AND a1 <> a2
  AND (
        (a1.actStartTime <= a2.actStartTime AND a1.actEndTime > a2.actStartTime)
        OR 
        (a2.actStartTime <= a1.actStartTime AND a2.actEndTime > a1.actStartTime)
      )
RETURN a1.actName AS activity1, a2.actName AS activity2, 
       r.roomName AS room, a1.actStartDate AS date,
       a1.actStartTime AS activity1_start, a1.actEndTime AS activity1_end,
       a2.actStartTime AS activity2_start, a2.actEndTime AS activity2_end
""" 

print("Running query...\n")
result = session.run(query)

# list to hold records
records = []
for record in result:
    records.append(record)

# df
df = pd.DataFrame(records, columns=["activity1", "activity2", "room", "date", 
                                   "activity1_start", "activity1_end", 
                                   "activity2_start", "activity2_end"])

# print
print(df)

# close session and driver
session.close()
driver.close()
```

### Room capacity exceeded

This query identifies activities where the number of students exceeds the room capacity. It includes an optional `WHERE` clause if looking at a specific date range.

```{cypher}{.scroll-cypher}
MATCH (r:room)<-[r1:OCCUPIES]-(a:activity)<-[:ATTENDS]-(s:student)
//WHERE a.Date >= date("2022-01-01") AND a.Date <= date("2022-06-30") 
WITH r, a, count(s) as numStudents
WHERE numStudents > r.roomCapacity
RETURN r, a.actStartDate, a.actName AS Activity, r.roomCapacity, numStudents - r.roomCapacity AS extraNeeded
ORDER BY extraNeeded DESC
```

These are the results in a dataframe: 

```{python}
from connect_to_neo4j_db import connect_to_neo4j
from neo4j import GraphDatabase
import pandas as pd

# connect to Neo4j
driver = connect_to_neo4j()

# session
session = driver.session()

# run query
query = """
MATCH (r:room)<-[r1:OCCUPIES]-(a:activity)<-[:ATTENDS]-(s:student)
//WHERE a.Date >= date("2022-01-01") AND a.Date <= date("2022-06-30") 
WITH r, a, count(s) as numStudents
WHERE numStudents > r.roomCapacity
RETURN DISTINCT r.roomName, r.roomType,  a.actName AS Activity, 
       r.roomCapacity, numStudents - r.roomCapacity AS extraNeeded
ORDER BY extraNeeded DESC
""" 

print("Running query...\n")
result = session.run(query)

# list to hold records
records = []
for record in result:
    records.append(record)

# df
df = pd.DataFrame(records, columns=["roomName", "roomType", "Activity", 
                                   "roomCapacity", "extraNeeded"])

# print
print("Printing first 5 records...\n")
print(df.head())

# close the session and driver
session.close()
driver.close()
```



### Student clashes

This query identifies students who are scheduled to attend two or more activities at the same time.  Identifying clashes is a complex undertaking and it is one where the graph structure in terms of nodes, properties and relationships could potentially make a significant different to performance. 

The reason for the complexity is that you need to look for overlapping times between two activities for each date, for each student.  The query to achieve this and the ensuing calculations will vary significantly depending on the structure and syntax. 

Because of this, I explored the student clash scenario in more detail here: [Student Clashes](appendix-cypher5a.qmd)

```{cypher}{.scroll-cypher}
MATCH (s:student)-[:ATTENDS]->(a1:activity)
WITH s, a1
MATCH (s)-[:ATTENDS]->(a2:activity) 
WHERE a1 <> a2 
  AND a1.actStartDate = a2.actStartDate 
  AND (a1.actStartTime < a2.actEndTime AND a1.actEndTime > a2.actStartTime)  
  AND NOT (a1.actStartTime = a2.actEndTime OR a1.actEndTime = a2.actStartTime) 
  AND a1.actName < a2.actName  // Ensure only one direction of the pair is returned
RETURN s.stuFirstName_anon AS Student, 
       a1.actStartDate AS ClashDate, 
       a1.actName AS Activity1, 
       a1.actStartTime + "-" + a1.actEndTime AS Timeslot1, 
       a2.actName AS Activity2, 
       a2.actStartTime + "-" + a2.actEndTime AS Timeslot2
ORDER BY Student, ClashDate;
```

![Student Clashes](./images/cypher-student-clash.png)